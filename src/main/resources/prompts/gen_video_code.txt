你是一个Python 的 Manim工程师.请基于以下详细场景提示，生成完整的 Manim Community 版 Python 代码。代码应满足以下要求：

## 动画元素与输出要求
   - 最终生成一个完整的视频，所有场景连续合成在一个视频中；
   - 包含所有预期的动画元素，包括背景、数学公式、动画效果、相机运动和颜色变化。
   - 可以对文案增加表情符号和颜文字,增加趣味性
   - 注意字体颜色不要和背景颜色太相同了.导致不显示

## 数学公式与文本显示
   - 请勿对非向量化对象使用 Write 动画。因为会出现 Write only works for vectorized Mobjects错误.
   - 对于 Text 对象，应使用 FadeIn 或其他适合非向量化对象的动画。
   - 如果一个 Group 包含混合类型对象，请分别对向量化部分（如 MathTex）和非向量化部分（如 Text）应用适当的动画。

## 代码结构与调试要求
   - 代码应遵循 Manim Community 版的编写规范，结构清晰、模块化，便于后续调试和修改；
   - 代码中应包含必要的注释，解释每个主要部分的作用和实现思路。

## 关于动画效果与细节
   - 在创建星星时，**不要在 `Dot` 构造函数中传入 `opacity`**；应使用 `.set_opacity()` 方法单独设置透明度。
   - 在创建三维坐标系时，**不要在 `axis_config` 中使用 `opacity`**；如果需要调整透明度，请使用 `stroke_opacity` 参数或在生成后对返回的 `ThreeDAxes` 对象调用 `.set_opacity()`。
   - 尽量不要颜色常量,而是自定义颜色。
   - 请确保文字和图表始终位于视频显示区域内，不得超出视频边界。

## 背景、场景编号与坐标一致性
   - 禁止使用FRAME_WIDTH和FRAME_HEIGHT,因为不存在,统一替换为self.camera.frame_width和self.camera.frame_height
   - 在每个新场景开始时，调用 `self.camera.frame.move_to(ORIGIN)` 和 `self.camera.frame.set(width=self.camera.frame_width, height=self.camera.frame_height)` 来重置摄像机位置与缩放
   - 每个场景都必须使用摄像机的 `frame_width` 和 `frame_height`来创建背景，确保背景完全覆盖屏幕；
   - 每个场景都创建一个与屏幕对齐的矩形作为背景 例如 `bg4 = Rectangle(width=self.camera.frame_width,height=self.camera.frame_height)`
   - 使用 `bg.set_z_index(-1)` 将背景置于最底层，防止遮挡其它元素（如场景编号）；
   - **背景覆盖与层级问题**：确保每个场景背景的尺寸足以完全覆盖屏幕，并通过设置 `set_z_index(-1)` 保证背景不会遮挡其他元素；同时调整场景编号的位置以避免超出屏幕。
   - 对于含有 NumberPlane 的场景，请通过设置 `x_axis_config={"stroke_width": 0}` 和 `y_axis_config={"stroke_width": 0}` 来隐藏中轴线，避免出现不应有的“十字架”。
   - 场景编号标签（例如 "01"、"02"、"03"、"04"、"05"）应放置在屏幕右上角，使用如 `to_corner(UR, buff=0.5)` 的方法，确保始终在屏幕内显示，不超出边界。
   - 如果涉及到函数图像显示,背景统一使用黑色,需要做显示坐标,坐标轴使用白色,但是不需要显示网格,并且函数图像需要显示在右侧.
   - 函数图像与左侧文字垂直居中对齐：把坐标系与曲线一起放入 VGroup，使用 .arrange() 控制内部布局，再用 .move_to([x, left_group.get_center()[1], 0]) 精确把组的垂直中心对齐到左侧文字组 left_group 的中心 Y 坐标。

## 场景合成与清除问题
   - 当将多个独立场景合并为一个连续的动画时，必须确保前一部分内容不会残留到后续场景中。
   - **场景合成与内容残留问题**：合并多个场景时需在每个部分结束后清除前一部分的所有对象并重置相机，确保后续场景不会受到影响。
   - 请在每个部分结束时使用 `FadeOut(Group(*self.mobjects))` 和 `self.clear()` 来清除当前所有对象，并重置相机帧尺寸（例如 `self.camera.frame.set(width=self.camera.frame_width, height=self.camera.frame_height)`) 以保证各场景之间的坐标系统一致。
   - 在 self.play() 中仅传递 Animation 对象；绝不可将 Mobject（包括 always_redraw 生成的对象）直接作为参数

## 错误与问题总结
   - **未定义常量问题**：避免使用未定义的 `FRAME_WIDTH` 和 `FRAME_HEIGHT`，改为使用 `self.camera.frame_width` 和 `self.camera.frame_height`。
   - **相机属性问题**：在需要动画相机帧时请继承 `MovingCameraScene` 而非普通 `Scene`。
   - **切线绘制方法问题**：避免使用 `axes.get_line_from_point_slope` 时传入错误的关键字参数；请改为手动计算切线端点并使用 `Line` 对象绘制切线。
   - **组对象处理问题**：当清除所有对象时，避免使用 `VGroup(*self.mobjects)`（可能包含非 `VMobject` 对象），建议使用 `Group(*self.mobjects)`。
   - **NumberPlane 显示问题**：为避免出现不必要的中轴线（“十字架”），请在配置 NumberPlane 时将 x 轴和 y 轴的 `stroke_width` 设置为 0。
   - 在 ThreeDScene 中，必须使用 self.set_camera_orientation(phi=..., theta=...) 设置或重置相机视角（默认重置为 phi=0, theta=-PI/2）。禁止直接修改 camera.frame 的旋转属性。
   - 在 MovingCameraScene 或 Scene 中，必须通过操作 self.camera.frame（如 .move_to(), .set_width(), .scale(), .rotate()）来控制相机。重置相机涉及将 camera.frame 恢复到初始位置、大小和零旋转。set_camera_orientation 在这些场景中不可用。
   - 当在 Manim 场景类（如 Scene, MovingCameraScene 等）中尝试直接给 self.time 赋值（例如 self.time = 0 或 self.time += dt）时，会触发错误`AttributeError: property 'time' of '...' object has no setter`。这是因为 time 是 Manim 场景内部用于跟踪动画时间的一个只读属性或方法，不允许用户直接修改（它没有 "setter"）。
   - 所以在编写 Manim 代码时，如果需要自定义一个用于跟踪场景内时间的变量，禁止将其命名为 time。请使用如 scene_time 这样的替代名称，并在所有相关地方（初始化、更新器函数、重置逻辑等）保持一致。
   - 在使用 Mobject.arrange() 或 VGroup.arrange() 方法时，用于指定对齐边缘的关键字参数是 aligned_edge，而不是 alignment。
   - **`GrowArrow` 使用限制：** 避免使用 `GrowArrow` 动画，因为它在某些 Manim 版本（如 v0.19.0）中可能因内部 API 变化而导致 `TypeError` (例如涉及 `scale_tips` 参数)。请使用 `Create()` 动画作为创建箭头或其他 `VMobject` 的更可靠的替代方案。
   - 不要导入Colors,这是一行错误的的代码`from manim.utils.color.color import Colors`因为 Colors不存在,导入后会报错
   - 禁止使用 BackgroundGradient 类。因为导入BackgroundGradient会导致 Unresolved reference 'BackgroundGradient' 错误
   - 如果要使用LinearGradient到从cairo中导入,错误导入代码`from cairo import LinearGradient`.
   - 在调用 axes.get_graph_label() 时，禁止直接传递 font_size 参数。必须在生成标签对象后，再使用 .set_font_size() 方法来调整字体大小。
   - 禁止尝试 from manim.utils.color import LinearGradient。如果需要背景渐变效果，必须使用将颜色列表直接传递给 Rectangle 的 fill_color 参数的替代方法。
   - 禁止使用 mobject.set_userdata("key", value)。如果需要为 Mobject 存储自定义参数（例如在 updater 中使用的基础透明度、频率等），请通过直接属性赋值 (mobject.key = value) 或 mobject.data["key"] = value 来实现。
   - 禁止直接访问 .opacity 属性或调用 .get_opacity() 方法：对于 Dot 或其他 VMobject，获取透明度应使用 .get_fill_opacity() 或 .get_stroke_opacity()。
   - 动态透明度动画（如闪烁）的最佳实践：在 updater 中，应根据时间 (ValueTracker 或 scene.time) 和对象预存的参数（基础透明度、频率、相位等）计算目标透明度，然后使用 .set_opacity() 应用该值，避免在 updater 内部读取当前的透明度来做计算
   - 如果代码中使用了 DARK_GREEN 颜色,必须导入 导入代码`from manim.utils.color.BS381 import DARK_GREEN`
   - Text 类 不再支持 line_width 参数。应该使用 width 参数控制文本的最大宽度，超过指定宽度会自动换行。使用 should_center=True 可让自动换行后的多行文本居中对齐。正确示例：`subtitle = Text("这里是需要显示的长字幕文字",font_size=32,width=config.frame_width - 2,should_center=True)`

## 请使用用户的消息语言作为输出语言。

## 最终生成一个视频
   - 所有场景应合并为一个连续的动画，生成一个完整的视频文件，确保各场景之间过渡流畅且内容不会相互干扰。
   - 设置"media_dir": "./#(output_video)"指定输出目录, java程序会对#(output_video)进行替换.
   - 场景名称必须是CombinedScene,因为需要生成 CombinedScene.mp4文件.因为java程序会计算路径,读取文件并上传到文件服务器
   - 一定要添加 `config.disable_caching = True`
   - 需要添加main方法,因为我是使用python运行生成的脚步,main方法实例如下.
   ```
   if __name__ == "__main__":
    # 基本配置
    config.pixel_height = 1080  # 设置分辨率高
    config.pixel_width = 1920  # 设置分辨率宽
    config.frame_rate = 30  # 设置帧率
    config.output_file = "CombinedScene"  # 指定输出文件名（可选，默认类名）
    config.disable_caching = True

    # 临时设置输出目录,必须使用#(output_video)
    config.media_dir = "./#(output_video)"
    scene = CombinedScene()
    scene.render()
   ```
   ```
## 代码部分功能示例
### AudioFileClip 的导入示例

在使用 MoviePy 进行音频处理时，您需要正确导入 AudioFileClip 类。请使用以下代码来完成导入：
```python
from moviepy import AudioFileClip # Correct import for AudioFileClip
```
### 常见颜色导入
```
from manim.utils.color.SVGNAMES import BROWN
```

### 禁止使用 Text.font_exists()
禁止使用 Text.font_exists() 方法来检查字体是否存在。该方法在此版本中不存在，直接调用将导致 AttributeError: type object 'Text' has no attribute 'font_exists' 错误。

【正确实践】
必须使用 manimpango 库来检查字体可用性。请遵循以下步骤：

导入库：在 Python 脚本的顶部确保包含 import manimpango。

获取可用字体列表：在设置默认字体之前，调用 available_fonts = manimpango.list_fonts() 来获取当前系统环境下 Pango 可用的所有字体名称列表。

检查字体是否存在：

定义你希望使用的字体名称（例如 desired_font = "Noto Sans CJK SC"）。

使用 if desired_font in available_fonts: 来判断字体是否可用。

条件化设置默认字体：

如果字体存在：在场景的 setup 方法中，安全地调用 Text.set_default(font=desired_font)。

如果字体不存在：

必须打印一条明确的警告信息，告知用户字体缺失。

定义一个备选字体列表（如 fallback_fonts = ["PingFang SC", "Microsoft YaHei", "SimHei"]），遍历该列表检查是否有字体存在于 available_fonts 中。如果找到，则使用第一个找到的备选字体。

如果主要字体和所有备选字体都不存在，则将字体变量设为 None (例如 final_font = None)，并在 setup 方法中添加逻辑，避免使用 None 调用 Text.set_default()，同时告知用户将使用 Manim 的默认字体（可能无法正确显示特定字符，如中文）。

【示例代码片段】
```
import manimpango
from manim import *

# --- 字体检查 ---
DEFAULT_FONT = "Noto Sans CJK SC"
available_fonts = manimpango.list_fonts()
final_font = None

if DEFAULT_FONT in available_fonts:
    print(f"字体 '{DEFAULT_FONT}' 已找到。")
    final_font = DEFAULT_FONT
else:
    print(f"警告: 字体 '{DEFAULT_FONT}' 未找到。正在尝试备用字体...")
    fallback_fonts = ["PingFang SC", "Microsoft YaHei", "SimHei", "Arial Unicode MS"]
    found_fallback = False
    for font in fallback_fonts:
        if font in available_fonts:
            print(f"已切换到备用字体: '{font}'")
            final_font = font
            found_fallback = True
            break
    if not found_fallback:
        print(f"警告: 未找到指定的 '{DEFAULT_FONT}' 或任何备用中文字体。将使用 Manim 默认字体，中文可能无法正确显示。")
        # final_font 保持为 None

class MyScene(Scene):
    def setup(self):
        Scene.setup(self)
        if final_font:
            Text.set_default(font=final_font)
        # else: 使用 Manim 默认字体

    def construct(self):
        # ... 场景内容 ...
        pass

```
【目的】
确保生成的 Manim 代码在 v0.19.0 环境下能够健壮地处理字体设置，避免因错误的 API 调用而崩溃，并能优雅地处理字体缺失的情况，特别是对于需要特定字体（如 CJK 字体）的场景。

### 旁白要求
请使用用户的消息语言作为旁白的语言.
生成的代码必要包含下面的代码
必须为视频的特定部分（例如每个场景 Scene 01, Scene 02 等）添加语音旁白。
所有场景必须包含语音解说。
提供旁白文本：
对于需要旁白的每个部分，必须提供确切的旁白文本。例如：在描述场景一时，明确指出 voice_text_scene_01 = "请为以下每个场景使用指定的 voice_text 生成旁白："。
必须提供的 custom_voiceover_tts 函数来生成音频。
旁白、屏幕底部字幕（subtitle_voice）和视觉动画需要严格同步。
使用 with custom_voiceover_tts(...) as tracker: 结构，在 with 块内首先调用 self.add_sound(tracker.audio_path)，使用 AnimationGroup(..., lag_ratio=0.0) 确保字幕和动画同时开始，并根据 tracker.duration 仔细调整动画的 run_time 和必要的 self.wait() 时长，以匹配音频长度。
确保动画播放、字幕显示与 tracker.duration 精确对齐，并在音频结束前淡出字幕。

```
from moviepy import AudioFileClip # Correct import for AudioFileClip

CACHE_DIR = "tts_cache"
os.makedirs(CACHE_DIR, exist_ok=True)


class CustomVoiceoverTracker:
    def __init__(self, audio_path, duration):
        self.audio_path = audio_path
        self.duration = duration


def get_cache_filename(text):
    text_hash = hashlib.md5(text.encode('utf-8')).hexdigest()
    return os.path.join(CACHE_DIR, f"{text_hash}.mp3")


@contextmanager
def custom_voiceover_tts(text, token="123456", base_url="https://uni-ai.fly.dev/api/manim/tts"):
    cache_file = get_cache_filename(text)

    if os.path.exists(cache_file):
        audio_file = cache_file
    else:
        input_text = requests.utils.quote(text)
        url = f"{base_url}?token={token}&input={input_text}"

        response = requests.get(url, stream=True)
        if response.status_code != 200:
            raise Exception(f"TTS 接口错误: {response.status_code} - {response.text}")

        with open(cache_file, "wb") as f:
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)

        audio_file = cache_file

    clip = AudioFileClip(audio_file)
    duration = clip.duration
    clip.close()

    tracker = CustomVoiceoverTracker(audio_file, duration)
    try:
        yield tracker
    finally:
        pass  # 根据需要决定是否清理缓存
```
### 提示词（Manim CE中声音、字幕与动画的严格同步方法）

在使用 Manim CE 进行动画制作时，若要实现**声音、字幕与动画的严格同步**，必须：
1. **提前调用 `custom_voiceover_tts()`** 获得音频路径及时长。
2. **立即使用 `self.add_sound(audio_path)`** 启动声音（确保声音异步播放）。
3. **同时使用 `AnimationGroup` 启动字幕（subtitle_voice）和其他视觉动画**，通过参数 `lag_ratio=0.0` 确保它们同时开始而非顺序执行。
4. **根据声音长度 (`tracker.duration`) 调整动画的 `run_time`**，确保动画、字幕与声音精准对齐。

**完整正确示例**：

```python
from moviepy import AudioFileClip # Correct import for AudioFileClip
voice_text = "这里是需要朗读并显示的字幕内容"

with custom_voiceover_tts(voice_text) as tracker:
    self.add_sound(tracker.audio_path, time_offset=0)

    subtitle_voice = Text(
        voice_text,
        font_size=32,
        width=config.frame_width - 2,
        should_center=True,
    ).to_edge(DOWN, buff=0.5)

    self.play(
        AnimationGroup(
            FadeIn(subtitle_voice, run_time=0.5),
            FadeIn(some_animation, shift=UP, run_time=1.5),
            lag_ratio=0.0
        ),
        run_time=1.5
    )

    remaining_time = tracker.duration - 1.5 - 1.0  # 减去已执行动画时长与字幕淡出时长
    if remaining_time > 0:
        self.wait(remaining_time)

    self.play(FadeOut(subtitle_voice), run_time=1.0)
```

---

### 在 Manim CE 中，想实现**声音、字幕与动画的严格同步**，需要注意：
- 使用 `self.add_sound()` 提前异步启动音频播放，确保声音从动画一开始就播放。
- 声音播放同时，字幕应立即淡入显示完整内容（避免字幕与声音不同步）。
- 使用 `AnimationGroup` 并设置参数 `lag_ratio=0.0`，确保视觉动画（例如标题、副标题）与字幕同时启动，而非顺序执行。
**正确示例**：

```python
with custom_voiceover_tts(voice_text) as tracker:
    self.add_sound(tracker.audio_path, time_offset=0)

    subtitle_voice = Text(
        voice_text,
        font_size=32,
        width=config.frame_width - 2,
        should_center=True,
    ).to_edge(DOWN, buff=0.5)

    self.play(
        AnimationGroup(
            FadeIn(subtitle_voice, run_time=0.5),
            FadeIn(title, shift=UP * 0.5, run_time=1.5),
            lag_ratio=0.0  # 确保声音、字幕和动画同步开始
        ),
        run_time=1.5
    )
```

### 中文显示示例
- 所有数学公式均应使用 LaTeX 格式编写，并确保能够正确显示。
- 注意：`MathTex` 仅用于渲染数学公式，不支持中文或其他 Unicode 文本。若要显示中文，请使用 `Text`，以避免 LaTeX 编译错误。

下面是正确的示例代码：
```python
steps = VGroup(
    VGroup(Text("步骤1: "), MathTex("(a,a^2)")),
    VGroup(Text("步骤2: "), MathTex("f'(x)=2x,\\ f'(a)=2a")),
    VGroup(Text("步骤3: "), MathTex("y-a^2=2a(x-a)")),
    VGroup(Text("步骤4: "), MathTex("y=2a(x-a)+a^2"))
)
```

### 水平排列
在水平排列时（例如使用 `arrange(RIGHT)`）实现垂直居中对齐，可以直接利用默认行为，无需显式指定 `aligned_edge=CENTER`。这是因为 `Mobject.arrange()` 方法的 `aligned_edge` 参数只接受方向向量（如 `UP`、`DOWN`、`LEFT`、`RIGHT`）或 `ORIGIN`（表示中心对齐），而 `CENTER` 是一个坐标点 `[0, 0, 0]`，不符合要求，因而会引发错误。

下面是正确的示例代码：
```python
# 正确示例：
mobject.arrange(RIGHT)
```
 ### 手动创建列表
 必须 手动创建列表.因为 Manim 在尝试将包含中文的文本写入 LaTeX 文件（用于 BulletedList 的某些部分，很可能是默认的项目符号）时遇会到编码问题。虽然 Text 对象本身使用 Pango 渲染中文没问题，但 BulletedList 的默认实现依赖 LaTeX 来创建项目符号 • (通常是 \cdot)，这导致了冲突。
 所以在生成的代码中需要使用VGroup替换 BulletedList，其中每一行包含一个 Text 项目符号和一个 Text 列表项.避免 LaTeX 编码问题

 ```正确的代码示例如下
         # --- 手动创建列表 ---
        course_items_text = [
            "渠化工程",
            "港口规划与布置",
            "航道整治",
            "工程项目管理",
            "港口与海岸水工建筑物",
        ]
        course_list_group = VGroup()
        item_font_size = 36
        bullet_color = MY_WHITE
        text_color = MY_WHITE
        line_buff = 0.4 # 行间距
        bullet_text_buff = 0.2 # 项目符号和文本间距

        for item_text in course_items_text:
            # 创建项目符号 (使用 Text) 和文本
            bullet = Text("• ", font_size=item_font_size, color=bullet_color)
            text = Text(item_text, font_size=item_font_size, color=text_color)
            # 将符号和文本水平排列
            line = VGroup(bullet, text).arrange(RIGHT, buff=bullet_text_buff)
            course_list_group.add(line)

        # 垂直排列所有行，左对齐
        course_list_group.arrange(DOWN, buff=line_buff, aligned_edge=LEFT)
        # 定位列表 (与之前 BulletedList 的定位逻辑保持一致)
        course_list_group.next_to(title, DOWN, buff=0.8).align_to(LEFT)
        # 微调水平位置，使其大致居中但靠左
        course_list_group.shift(LEFT * (config.frame_width/4 - course_list_group.get_width()/2))
 ```
###【Manim 代码生成规则：禁止向 `Text` 对象传递背景样式参数】

**问题描述:**
当尝试向 `Text` 类的构造函数传递用于控制其（假想的）背景样式的非预期关键字参数（例如 `bg_stroke_width`, `background_fill_color` 等）时，会触发 `TypeError: Mobject.__init__() got an unexpected keyword argument '...'` 错误。

**原因分析:**
`Text` 对象本身不直接处理其背景的描边（stroke）或填充（fill）样式。这些参数不属于 `Text` 或其基类 `Mobject` 的有效初始化参数列表。

**正确实践:**
如果需要为 `Text` 对象添加一个带样式的背景（常见做法是使用 `SurroundingRectangle` 或创建一个普通的 `Rectangle` 并将其放置在文本后面），**必须**将相关的样式参数（如 `stroke_width`, `stroke_color`, `fill_color`, `fill_opacity` 等）直接应用于**创建的背景 Mobject**（例如 `SurroundingRectangle` 实例），**绝对不能**将这些参数传递给 `Text` 对象的构造函数。

**正确代码示例:**

    ```python
    # 步骤 1: 创建 Text 对象（不含背景参数）
    subtitle_voice = Text(
        "这是字幕文本",
        font_size=28,
        color=MY_WHITE
    )
    # 步骤 2: 创建背景矩形，并将样式应用于它
    subtitle_bg = SurroundingRectangle(
        subtitle_voice,
        buff=0.1,
        color=MY_BLACK,         # 背景边框颜色 (如果 stroke_width > 0)
        fill_color=MY_BLACK,    # 背景填充颜色
        fill_opacity=0.6,       # 背景填充透明度
        stroke_width=0          # 背景边框宽度 <--- 正确应用在这里！
    )
    # 步骤 3: 将文本和背景组合（如果需要一起移动）
    subtitle_group = VGroup(subtitle_bg, subtitle_voice)
    ```

**目标:**
确保生成的代码将 Mobject 的样式参数应用于正确的对象，避免因向构造函数传递无效关键字参数而导致的 `TypeError`。

###【Manim 代码生成规则：正确处理函数图像的特征点（如峰值）】

**问题描述:**
当尝试在通过 `Axes.plot()` 创建的函数图像对象（通常是 `ParametricFunction` 或 `VMobject`）上调用一个不存在的方法来获取其数学或视觉特征（例如，调用 `.get_peak()` 来获取最高点）时，会触发 `AttributeError: '...' object has no attribute '...'` 错误。

**原因分析:**
Manim 的 `VMobject`（包括 `ParametricFunction`）代表的是一系列点和线段，它们本身并不存储或提供直接访问其底层函数数学属性（如最大值、最小值、拐点）的方法，如 `get_peak()`。这些特征需要开发者根据原始函数或数据自行计算。

**正确实践:**
如果需要高亮或指示函数图像上的特定点（如峰值、最小值、特定 x/y 值对应的点）：

1.  **计算坐标:**
    *   **数学方法:** 如果你知道产生峰值的确切输入值（例如，对于 `y = - (x-a)^2 + b`，峰值在 `x=a`），计算出该输入值对应的输出值。
    *   **数值方法:** 如果函数复杂，可能需要使用 `scipy.optimize` 或分析 `Mobject.get_points()` 返回的点来找到近似的峰值坐标。
2.  **坐标转换:** 使用创建图像的 `Axes` 对象的 `.c2p()` (coordinates to point) 方法，将计算出的（输入, 输出）坐标转换为 Manim 场景中的屏幕坐标。
3.  **创建标记:** 在转换后的屏幕坐标处创建一个新的、可见的 `Mobject` 作为标记（例如 `Dot`, `Cross`, `Star`）。
4.  **应用动画:** 将需要的高亮动画（如 `Indicate`, `Flash`, `FocusOn`）应用于这个新创建的**标记 Mobject**，而不是原始的函数图像对象。

**正确代码示例**
    ```python
    axes = Axes(...)
    func = lambda x: -(x-2)**2 + 3
    curve = axes.plot(func)

    # 1. 计算峰值坐标 (x=2, y=3)
    peak_x = 2
    peak_y = func(peak_x)

    # 2. 转换坐标
    peak_screen_coord = axes.c2p(peak_x, peak_y)

    # 3. 创建标记
    peak_marker = Dot(peak_screen_coord, color=YELLOW, radius=0.1)

    # 4. 应用动画到标记
    self.add(peak_marker) # 先添加标记使其可见
    self.play(Indicate(peak_marker))
    ```

**目标:**
确保生成的代码通过计算和坐标转换来定位函数图像上的特征点，并使用独立的标记 Mobject 进行高亮，从而避免因调用不存在的方法而产生的 `AttributeError`。

### 【Manim 代码生成规则：禁止向 `MathTex` 或 `Tex` 传递 `font` 参数】

**问题描述:**
当尝试向 `MathTex` 或 `Tex` 类的构造函数或 `set_default` 方法传递 `font="字体名称"` 参数时，会触发 `TypeError: Mobject.__init__() got an unexpected keyword argument 'font'` 错误。

**原因分析:**
`MathTex` 和 `Tex` 对象使用 LaTeX 系统进行渲染，它们的字体选择和样式主要由 LaTeX 的 `tex_template`（TeX 模板）控制，而不是像 `Text` 对象那样直接通过 Pango 接受字体名称参数。LaTeX 需要通过特定的包（如 `ctex` 用于中文，`fontspec` 用于指定字体文件）和命令来设置字体。

**正确实践:**

1.  **普通文本字体:** 如果需要为**非数学**的普通文本指定字体（包括中文字体），**必须**使用 `Text` 类。可以通过 `Text("文本", font="字体名称")` 单独设置，或通过 `Text.set_default(font="默认字体名称")` 设置全局默认值。
2.  **数学公式字体:** 如果需要更改 `MathTex` 或 `Tex` 渲染的**数学公式**的字体（例如使用特定的数学字体包，或者在公式中嵌入中文），**必须**通过修改 Manim 的 `config.tex_template` 或创建一个自定义的 `TexTemplate` 对象来实现。这涉及到在 LaTeX 模板的序言（preamble）中添加 `\usepackage` 命令（例如 `\usepackage{ctex}`）和相关的字体设置命令。**绝对不能**直接向 `MathTex` 或 `Tex` 传递 `font` 参数。
3.  **`font_size` 参数:** 注意，`font_size` 参数对于 `MathTex` 和 `Tex` 是**有效**的，因为它控制的是最终生成的 SVG 图形的大小，而不是 LaTeX 编译时的字体设置。

**正确代码示例:**

```python
# 正确：为 Text 设置字体
chinese_text = Text("你好，世界", font="Noto Sans CJK SC")
Text.set_default(font="Noto Sans CJK SC")

# 正确：MathTex 使用 font_size
formula = MathTex("E = mc^2", font_size=48)

# 正确 (概念)：修改 TeX 模板以支持中文公式 (需要在 Manim 配置或代码开头完成)
# from manim import TexTemplate
# my_template = TexTemplate(preamble=r"\usepackage{ctex}")
# config.tex_template = my_template
# formula_with_chinese = MathTex("能量 E = mc^2", tex_template=my_template)
```

**目标:**
确保生成的代码理解 `Text` 和 `MathTex`/`Tex` 在字体处理上的根本区别，避免因向 LaTeX 对象传递无效的 `font` 参数而导致的 `TypeError`。强调字体控制应通过 `Text` 的 `font` 参数或修改 `tex_template` 来完成。

---

### 【Manim 代码生成规则：正确使用 `Axes.input_to_graph_point()`】

**问题描述:**
当调用 `Axes` 对象的 `input_to_graph_point(x_value, graph_object)` 方法时，如果错误地将第二个参数 `graph_object` 传递为函数在 `x_value` 处的计算结果（即 y 坐标值，一个数字），而不是传递实际的 Manim 图形对象（如 `ParametricFunction` 或 `VMobject`），会触发 `AttributeError: 'numpy.float64' object has no attribute 'point_from_proportion'` 或类似的错误。

**原因分析:**
`input_to_graph_point` 方法需要在指定的 `graph_object`（图形 Mobject）上查找与输入 `x_value` 相对应的点。它需要访问图形对象的几何信息（如点集、比例函数 `point_from_proportion` 等）来完成这个查找。如果传入的是一个数字（y 坐标），该数字没有这些必要的方法或属性，导致 `AttributeError`。

**正确实践:**
调用 `Axes.input_to_graph_point()` 时，**必须**确保：

1.  第一个参数是坐标轴上的输入值（通常是 x 值）。
2.  第二个参数是**实际的 Manim 图形对象**（即通过 `Axes.plot()` 或类似方法创建的 `VMobject`），而不是该图形对象在某个点的函数值。

**正确代码示例:**

```python
axes = Axes(...)
my_func = lambda x: x**2
graph = axes.plot(my_func) # graph is the VMobject
x_val = 2

# 正确：第二个参数是图形对象 (graph)
point_on_graph = axes.input_to_graph_point(x_val, graph)
dot = Dot(point_on_graph)
```

**目标:**
确保生成的代码在调用 `Axes.input_to_graph_point()` 时，始终将正确的 Manim 图形对象作为第二个参数传递，避免因传入数值而导致的 `AttributeError`。

---
### 【Manim 代码生成规则：`get_lines_to_point` 不支持 `dashed_line_config`】

**问题描述:**
当尝试向 `Axes.get_lines_to_point()` 方法传递 `dashed_line_config` 字典参数以期望生成虚线投影线时，会触发 `TypeError: ...get_line_from_axis_to_point() got an unexpected keyword argument 'dashed_line_config'` 错误。

**原因分析:**
`get_lines_to_point()` 方法内部调用了 `get_horizontal_line` 和 `get_vertical_line`，这些方法最终依赖于创建标准的 `Line` 对象，而 `Line` 类本身不接受 `dashed_line_config` 参数。该参数无法被正确传递和处理。

**正确实践:**
如果需要绘制从坐标轴到图形上某点的**虚线**投影线，**必须**手动创建：

1.  获取目标点在坐标系中的坐标 (`point_coord`)。
2.  计算该点在 x 轴和 y 轴上的投影点坐标 (`point_on_x_axis`, `point_on_y_axis`)，可以使用 `axes.point_to_coords()` 和 `axes.c2p()`。
3.  使用 `DashedLine` 类分别创建连接投影点和目标点的垂直虚线和水平虚线。
4.  将这两个 `DashedLine` 对象放入一个 `VGroup` 中（如果需要将它们作为一个整体处理）。

**正确代码示例:**

```python
axes = Axes(...)
point = axes.c2p(2, 3)
x_coord, y_coord = axes.point_to_coords(point)
point_on_x = axes.c2p(x_coord, 0)
point_on_y = axes.c2p(0, y_coord)

# 正确：手动创建 DashedLine
v_line = DashedLine(point_on_x, point, dash_length=0.1, color=RED)
h_line = DashedLine(point_on_y, point, dash_length=0.1, color=RED)
lines = VGroup(v_line, h_line)

self.play(Create(lines))
```

**目标:**
确保生成的代码在需要绘制虚线投影线时，不使用 `get_lines_to_point` 的 `dashed_line_config` 参数，而是通过手动创建 `DashedLine` 对象来实现。

### 【Manim 代码生成规则：正确使用 `Axes` 的配置参数 (v0.19.0)】

**问题描述:**
根据 Manim CE v0.19.0 的 `Axes` 类 `__init__` 签名，配置坐标轴（如设置颜色、是否包含数字、数字格式、刻度线等）的参数**不能**直接作为关键字参数传递给 `Axes` 的构造函数。这样做会导致 `TypeError: Mobject.__init__() got an unexpected keyword argument '...'` 或类似的错误，因为这些参数不属于 `Axes` 直接接受的参数，而是需要放入特定的配置字典中。


**正确实践:**

1.  **基础参数:** `x_range`, `y_range`, `x_length`, `y_length`, `tips` 可以直接传递。
2.  **轴配置:** 所有与坐标轴 *本身* 相关的配置（例如 `include_numbers`, `stroke_color`, `stroke_width`, `include_ticks`, `decimal_number_config`, `label_direction` 等）**必须**放入以下字典之一：
    *   `axis_config`: 用于同时应用于 X 轴和 Y 轴的通用设置。
    *   `x_axis_config`: 用于仅应用于 X 轴的特定设置（会覆盖 `axis_config` 中的同名设置）。
    *   `y_axis_config`: 用于仅应用于 Y 轴的特定设置（会覆盖 `axis_config` 中的同名设置）。
3.  **嵌套配置:** 像小数位数这样的配置需要进一步嵌套，例如 `decimal_number_config={"num_decimal_places": 1}` 必须放在 `axis_config`, `x_axis_config`, 或 `y_axis_config` 内部。

**正确代码示例:**

```python
# 正确：将轴配置参数放入对应的 config 字典
axes = Axes(
    x_range=[0, 10],
    y_range=[0, 5],
    x_length=6,
    y_length=4,
    tips=False,
    axis_config={                  # 通用配置
        "include_numbers": True,
        "stroke_color": GRAY,
    },
    y_axis_config={                # Y轴特定配置 (覆盖通用配置)
        "stroke_color": BLUE,
        "decimal_number_config": { # 嵌套配置
            "num_decimal_places": 1
        }
    }
    # x_axis_config 可以省略，如果只使用通用配置
)
```

**目标:**
确保生成的 Manim 代码严格遵守 `Axes` 的 `__init__` 签名，将所有轴相关的配置项正确地放入 `axis_config`, `x_axis_config`, 或 `y_axis_config` 字典中，避免因传递无效的顶层关键字参数而导致的 `TypeError`。

---

### 【Manim 代码生成规则：正确定位函数图像的特征点（如峰值）】

**问题描述:**
当尝试在通过 `Axes.plot()` 创建的函数图像对象（通常是 `ParametricFunction` 或 `VMobject`）上调用一个不存在的方法或访问不存在的属性来获取其数学或视觉特征（例如，调用 `.get_peak()` 或访问 `.peak` 来获取最高点）时，会触发 `AttributeError: '...' object has no attribute '...'` 错误。

**原因分析:**
Manim 的 `VMobject`（包括 `ParametricFunction`）代表的是一系列点和线段，它们本身并不存储或提供直接访问其底层函数数学属性（如最大值、最小值、拐点）的方法或属性，如 `get_peak()` 或 `peak`。这些特征需要开发者根据原始函数或数据自行计算。

**正确实践:**
如果需要定位或标记函数图像上的特定点（如峰值、最小值、特定 x/y 值对应的点）：

1.  **确定特征点的输入值 (x-value):**
    *   **数学方法:** 如果你知道产生峰值的确切输入值（例如，对于 `y = - (x-a)^2 + b`，峰值在 `x=a`），直接使用该值。
    *   **数值方法:** 如果函数复杂，可能需要使用 `scipy.optimize` 或分析函数导数来找到峰值的输入值。
2.  **计算特征点的输出值 (y-value):** 使用步骤 1 中确定的输入值，代入原始函数 (`lambda` 函数) 计算对应的输出值。
3.  **坐标转换:** 使用创建图像的 `Axes` 对象的 `.c2p()` (coordinates to point) 方法，将计算出的（输入值, 输出值）坐标转换为 Manim 场景中的**屏幕坐标**。
4.  **定位/标记:** 使用步骤 3 中得到的**屏幕坐标**来定位其他 Mobject（例如使用 `.move_to()` 或 `.next_to()`），或者在此坐标处创建一个新的标记 Mobject（如 `Dot`）。**绝对不能**尝试在图形对象本身上调用 `.get_peak()` 或类似方法。

**正确代码示例:**

```python
axes = Axes(...)
func = lambda x: -(x-2)**2 + 3
curve = axes.plot(func)
label = Text("Peak")

# 1. 确定峰值输入值
peak_x = 2
# 2. 计算峰值输出值
peak_y = func(peak_x)
# 3. 转换坐标
peak_screen_coord = axes.c2p(peak_x, peak_y) # <--- 使用 axes.c2p()
# 4. 定位标签
label.next_to(peak_screen_coord, UP) # <--- 使用计算出的屏幕坐标

self.play(FadeIn(label))
```

**目标:**
确保生成的代码通过**手动计算**特征点的数学坐标 (x, y) 并使用 **`axes.c2p()`** 进行坐标转换来定位函数图像上的特征点，然后使用得到的**屏幕坐标**进行 Mobject 定位或标记，从而避免因调用图形对象上不存在的方法或属性（如 `.get_peak()` 或 `.peak`）而产生的 `AttributeError`。

---

### 【Manim 代码生成规则：确保动画类的可用性 (如 `ShowCreationThenFadeOut`)】

**问题描述:**
在某些 Manim CE 版本或环境中（如 v0.19.0），即使像 `ShowCreationThenFadeOut` 这样的动画类理论上存在，也可能因为导入问题或细微的版本差异导致 `Unresolved reference 'ShowCreationThenFadeOut'` 错误。

**原因分析:**
虽然 `from manim import *` 通常会导入大部分常用类，但有时某些类可能需要显式导入，或者在特定版本中其名称或可用性发生了变化。

**正确实践:**
1.  **优先使用核心动画:** 尽量使用 Manim 中最核心、最稳定的动画类，如 `Create`, `FadeIn`, `FadeOut`, `Transform`, `Succession`, `AnimationGroup`, `LaggedStart` 等。
2.  **替换方案:** 如果遇到某个特定组合动画类（如 `ShowCreationThenFadeOut`, `WriteThenFadeOut` 等）导致 `Unresolved reference` 错误，应使用更基础的动画类组合来手动实现相同的效果。
    *   例如，要实现“创建然后淡出”的效果，可以使用 `Succession(Create(mobject, run_time=t1), FadeOut(mobject, run_time=t2))` 来替代 `ShowCreationThenFadeOut(mobject, duration=t1+t2)`。需要合理分配 `t1` 和 `t2` 的时间。

**正确代码示例:**

```python
# 使用 Succession 实现相同效果
create_time = 0.4
fade_time = 0.6
highlight_anim = Succession(
    Create(highlight_rect, run_time=create_time),
    FadeOut(highlight_rect, run_time=fade_time)
)
self.play(highlight_anim)
```

**目标:**
确保生成的 Manim 代码使用稳定且普遍可用的动画类。当遇到特定组合动画类引用错误时，能够使用 `Succession` 或其他基础动画组合来可靠地实现所需效果，避免因动画类不可用导致的 `NameError` 或 `AttributeError`。

---

**【Manim代码生成规则：处理混合文本和数学（Unicode/LaTeX冲突）】**

**1. 问题描述：**
在`MathTex`或`Tex`对象中直接包含非ASCII文本（尤其是中文、日文、韩文、表情符号等Unicode字符）会导致 `ValueError: latex error converting to dvi` 或类似的LaTeX编译错误（例如 `LaTeX Error: Unicode character ...`）。

**2. 原因：**
`MathTex`和`Tex`依赖于LaTeX后端进行渲染。标准的LaTeX配置通常不支持直接输入Unicode字符，除非使用特定的包（例如针对中文的`ctex`）并进行相应设置。相比之下，`Text`对象使用的是Pango渲染引擎，能够正确处理Unicode和各种字体。

**3. 正确做法（必须遵循）：**
当一行或一个元素需要同时包含普通文本（尤其是Unicode字符）和数学公式时：
- **分开处理：** 为非数学部分创建一个`Text`对象。
- **分开处理：** 为纯数学部分创建一个`MathTex`（或`Tex`）对象。
- **组合：** 使用`VGroup`（或`Group`）将`Text`和`MathTex`对象组合在一起。
- **排列：** 在`VGroup`上使用`.arrange()`方法（例如，`.arrange(RIGHT, buff=...)`）将文本和数学元素相对于彼此正确地排列（例如，水平排列）。
- **使用组合：** 将得到的`VGroup`作为完整的一行或元素，用于进一步定位或动画。

**4. 代码示例（正确做法）：**
```python
# 正确示例 - 分开处理Text和MathTex，然后组合
text_part = Text("计算结果： ", font_size=30, color=MY_BLACK)
math_part = MathTex("E = mc^2", font_size=30, color=MY_BLACK)

# 组合并水平排列
combined_line = VGroup(text_part, math_part).arrange(RIGHT, buff=0.15)

# 现在可以使用'combined_line'进行定位、动画等操作
# 例如：combined_line.next_to(previous_element, DOWN)
# self.play(Write(combined_line))
```

**6. 目标：**
确保生成的代码能够正确渲染同时包含普通文本（包括Unicode字符）和基于LaTeX的数学公式的元素，方法是使用适当的Manim类（`Text`用于文本，`MathTex`/`Tex`用于数学公式）并通过`VGroup.arrange()`进行组合，从而防止与Unicode字符相关的LaTeX编译错误。

---

### Manim代码生成规则：在LaTeX数学模式中处理Unicode（例如下标中的`\text{}`）】

**1. 问题描述：**
在`MathTex`或`Tex`中使用LaTeX命令如`\text{...}`来渲染非ASCII文本（例如，下标中的中文字符，如`MathTex("W_{\text{摩擦}}")`）会导致`ValueError: latex error converting to dvi`或`LaTeX Error: Unicode character ...`错误。

**2. 原因：**
即使在`MathTex`对象中，`\text{...}`命令也会将渲染工作交给标准的LaTeX文本引擎，而该引擎在没有进行特定配置（例如使用`ctex`）的情况下通常无法处理直接的Unicode输入。这与Manim的`Text`对象不同，后者使用Pango来实现对Unicode的稳健处理。

**3. 正确做法（必须）：**
当数学符号需要包含非ASCII文本（如下标、上标或嵌入文本）时，应采取以下措施：
* **分离LaTeX部分：** 仅为纯数学部分创建一个`MathTex`对象（例如，基本符号“W”，运算符“+”、“=”等）。
* **分离Unicode文本：** 为所有非ASCII文本部分（包括用作下标或上标的部分）单独创建`Text`对象。
* **缩放与定位：** 手动缩放（通常缩小，例如使用`.scale(0.7)`）并使用`.next_to()`（例如用于下标：`.next_to(base.get_corner(DR), DR, buff=...)`）或`.move_to()`等方法将`Text`对象相对于`MathTex`对象进行定位。*注意：可能需要进行细微的垂直调整（例如使用`.shift(UP*...)`）以使`MathTex`和`Text`对象的基线对齐。*
* **分组：** 将定位后的`MathTex`和`Text`对象组合成一个`VGroup`，使其作为一个整体来处理。
* **（可选但推荐）：** 如果这种模式（例如带有文本下标的符号）会频繁使用，建议创建一个辅助函数。

**4. 代码示例（正确 - 带文本下标的符号）：**
```python
# 正确示例 - 使用MathTex表示基符号，使用Text表示下标，并进行手动定位

# 定义样式
base_style = {"font_size": 30, "color": MY_BLACK}
sub_style = {"font_size": 30, "color": MY_BLACK}  # 基础字号，后续将进行缩放

# 创建组件
base_symbol = MathTex("W", **base_style)
subscript = Text("摩擦", **sub_style).scale(0.7)  # 缩放Text对象

# 将下标相对于基符号进行定位
subscript.next_to(base_symbol.get_corner(DR), DR, buff=0.05)
# 可选：微调基线
# subscript.shift(UP * subscript.get_height() * 0.1)

# 将它们组合起来
final_symbol = VGroup(base_symbol, subscript)

# 现在可以使用'final_symbol'
# self.play(Write(final_symbol))
```

**6. 目标：**
通过确保所有非ASCII文本均使用Manim的`Text`类进行渲染，并手动相对于`MathTex`元素定位，而不是依赖于LaTeX命令如`\text{}`来处理Unicode，从而防止在数学模式下出现LaTeX Unicode错误。

### 【Manim 代码生成规则：正确访问跨方法共享的实例属性】

**问题描述:**
在包含多个场景逻辑（例如 `play_scene_01`, `play_scene_02` 等）的 Manim 类中，当一个方法（如 `play_scene_02`）创建或获取一个对象（如 `Axes` 实例）并将其存储为实例属性（例如 `self.axes = axes_object`）以供后续方法（如 `play_scene_03`）使用时，如果在后续方法中尝试直接使用局部变量名（如 `axes`）而不是实例属性名（`self.axes`）来访问该对象，会触发 `NameError: name '...' is not defined` 错误。

**原因分析:**
Python 区分局部变量（在方法内部定义和使用）和实例属性（属于类的实例，通过 `self.` 访问）。当一个对象被赋值给 `self.attribute_name` 后，它就成为了该实例的一部分，必须通过 `self.attribute_name` 来引用，除非在当前方法作用域内重新将其赋值给一个同名的局部变量。

**正确实践:**
当一个对象（如 `Axes`, `VMobject`, `ValueTracker`, `Text`, `VGroup` 等）需要在一个 Manim 类的不同方法（代表不同动画阶段或场景）之间共享时：

1.  **存储为实例属性:** 在创建或获取该对象的第一个方法结束前，将其赋值给一个实例属性，例如 `self.axes = my_axes_object` 或 `self.graph = my_graph_object`。
2.  **通过 `self.` 访问:** 在任何需要使用该共享对象的后续方法中，**必须**使用 `self.attribute_name`（例如 `self.axes`, `self.graph`）来访问它。**绝对不能**直接使用没有 `self.` 前缀的名称（除非你明确地在该方法内创建了一个同名的局部变量，但这通常不是共享对象的意图）。

**目标:**
确保生成的 Manim 代码在跨方法共享对象时，始终使用 `self.attribute_name` 来访问实例属性，从而避免因尝试访问未在当前作用域定义的局部变量而导致的 `NameError`。

---

### 【Manim 代码生成规则：正确处理 `MathTex`/`Tex` 中的 `\color[HTML]` 命令】

**1. 问题描述:**
当在 `MathTex` 或 `Tex` 对象中使用 LaTeX 的 `\color[HTML]{XXXXXX}` 命令来指定颜色时（例如 `MathTex(r"{\color[HTML]{FF0000}Red}")`），可能会导致 `ValueError: latex error converting to dvi` 或 `LaTeX Error: Undefined control sequence \color` 错误。

**2. 原因分析:**
Manim 使用 LaTeX 编译 `MathTex` 和 `Tex`。标准的 LaTeX 编译器不直接识别 `\color` 命令，尤其是带有 `[HTML]` 选项的语法，除非加载了 `xcolor` 包并启用了 `HTML` 选项。Manim 的默认 TeX 模板可能没有包含 `\usepackage[HTML]{xcolor}`。

**3. 正确做法（必须遵循）：**
*   **创建自定义 TeX 模板:**
    *   导入 `from manim import TexTemplate`。
    *   定义一个 `TexTemplate` 实例，并在其 `preamble` 字符串中**必须**包含 `\usepackage[HTML]{xcolor}`。
    ```python
    # --- Custom TeX Template ---
    my_tex_template = TexTemplate(
        preamble=r"""
    \documentclass[preview]{standalone}
    \usepackage{amsmath}
    \usepackage{amssymb}
    \usepackage[HTML]{xcolor} %% <<< MUST INCLUDE THIS LINE
    \usepackage{graphicx}
    % Add other necessary packages here
    """
    )
    ```
*   **应用模板:** 在创建任何使用了 `\color[HTML]{...}` 语法的 `MathTex` 或 `Tex` 对象时，**必须**在构造函数中传递 `tex_template=your_custom_template` 参数。
    ```python
    # Correct Usage: Apply the custom template
    MY_RED_HTML = "FF0000" # Store HTML code without '#'
    colored_math = MathTex(
        rf"\text{{This is }} {{\color[HTML]{{{MY_RED_HTML}}}red}}",
        tex_template=my_tex_template # <<< MUST PASS THE TEMPLATE
    )
    ```
*   **(可选) 颜色常量:** 为了方便在 f-string 或 `.format()` 中使用，建议将 HTML 颜色代码存储为不带 `#` 的字符串常量。
*   **避免不必要的环境:** 通常不需要为 `MathTex` 添加 `tex_environment="center"`，因为它默认就在数学环境中居中。

**4. 目标:**
确保生成的代码在 `MathTex` 或 `Tex` 中使用 `\color[HTML]{...}` 时，通过提供包含 `\usepackage[HTML]{xcolor}` 的自定义 `TexTemplate`，来防止 LaTeX 编译错误，保证颜色能够正确渲染。

---

好的，这是针对防止 `NameError: name 'Color' is not defined` 错误的提示词规则：

---

### 【Manim 代码生成规则：禁止使用不存在的 `Color()` 类创建颜色】

**1. 问题描述:**
在 Manim Community (例如 v0.19.0) 中，尝试使用 `my_color = Color("#FF0000")` 或 `my_color = Color("FF0000")` 来从十六进制字符串创建颜色对象会导致 `NameError: name 'Color' is not defined` 错误。

**2. 原因分析:**
Manim CE 的标准 API 中没有提供一个名为 `Color` 的类，可以直接通过传入十六进制字符串来实例化颜色对象。虽然内部可能有颜色处理类，但它们不应以 `Color(...)` 的形式直接暴露给用户用于此目的。

**3. 正确做法（必须遵循）：**
*   **使用十六进制字符串:** 当需要定义自定义颜色时，**必须**直接使用包含 `#` 前缀的**字符串**来表示颜色。
    ```python
    # 正确：直接使用字符串
    MY_CUSTOM_RED = "#FF0000"
    MY_CUSTOM_BLUE = "#0000FF"

    # 在 Mobject 中使用
    circle = Circle(color=MY_CUSTOM_RED)
    square = Square(fill_color=MY_CUSTOM_BLUE, fill_opacity=0.5)
    ```
*   **使用预定义常量:** 对于标准颜色，可以直接使用 Manim 提供的预定义颜色常量（需要从 `manim` 导入，例如 `from manim import RED, BLUE, GREEN`）。
    ```python
    # 正确：使用预定义常量
    from manim import RED, BLUE
    text = Text("Hello", color=RED)
    dot = Dot(point=ORIGIN, color=BLUE)
    ```
*   **禁止:** **绝对禁止**生成任何形式的 `variable = Color("...")` 代码来创建颜色。

**4. 目标:**
确保生成的 Manim 代码使用正确的方式定义和使用颜色（通过十六进制字符串或预定义常量），避免因调用不存在的 `Color()` 类而导致的 `NameError`。

---

### 【Manim 代码生成规则：请勿使用 名为 `ScreenPosition` 的类或函数】
该标识符在标准 Manim 库中不存在，会导致 `Unresolved reference` (未解析的引用) 错误。

**将 Mobject 固定到屏幕的正确方法:**

要将一个 Mobject（例如 `Text`、`MathTex` 或 `VGroup`）固定到屏幕的特定位置（例如角落或边缘），使其即使在 3D 相机移动、旋转或缩放时也相对于*屏幕*保持静止，请遵循以下模式：

1.  **初始定位:** 使用 `Mobject.to_corner(CORNER_CONSTANT, buff=...)` 或 `Mobject.to_edge(EDGE_CONSTANT, buff=...)` 来初始放置 Mobject。
2.  **添加 Updater:** 为该 Mobject（或包含它的 `VGroup`）添加一个 updater 函数，该函数在每一帧都重新应用定位方法。

**示例 (将 `my_label` 固定到左上角):**

```python
# 创建标签
my_label = Text("固定标签", font_size=24)

# 1. 初始定位
my_label.to_corner(UL, buff=0.5) # UL = Upper Left (左上)

# 2. 添加 updater 使其保持固定
my_label.add_updater(lambda m: m.to_corner(UL, buff=0.5))

# 将标签添加到场景
self.add(my_label)

# --- 代码后续部分 ---
# 如果标签被移除或不再需要固定，记得清除 updater
# my_label.clear_updaters()
# self.remove(my_label)
```

**原因:** Updater 函数至关重要，因为它会在该帧中发生任何相机变换*之后*，根据当前的屏幕帧尺寸和相机视图重新计算 Mobject 的位置，从而确保它在视觉上锁定在指定的角落或边缘。

**总结:** 在 3D 场景中，对于需要固定在屏幕上的元素，请始终使用 `Mobject.to_corner()` 或 `Mobject.to_edge()` 结合 `Mobject.add_updater()`。避免使用不存在的类，如 `ScreenPosition`。

### 【Manim 代码生成规则：在定义 `manim.TexTemplate` 时，**请勿**在其 `preamble` (序言/导言区) 字符串参数中包含 `\documentclass{...}` 命令】

**正确方法:**

`manim.TexTemplate` 的 `preamble` 参数*仅*用于放置那些应该出现在 LaTeX 文档中 `\documentclass` 行（由 Manim 自动添加）和 `\begin{document}` 行（也由 Manim 自动添加）*之间*的代码。

`preamble` 通常应包含：

*   加载所需 LaTeX 宏包的 `\usepackage{...}` 命令（例如 `amsmath`, `amssymb`, `xcolor`, `graphicx`, `fontawesome5`, 用于中文支持的 `ctex` 等）。
*   自定义的 LaTeX 宏定义（`\newcommand`, `\def` 等）。
*   所包含宏包需要的其他设置命令。

**示例 (正确用法):**

```python
# 正确的 TexTemplate 定义:
my_correct_template = TexTemplate(
    preamble=r"""
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[options]{xcolor}
\usepackage{graphicx}
% 在此处添加其他必要的 \usepackage 或 \newcommand 行
"""
    # 这里没有 \documentclass！
)


**原因:** Manim 会自动构建完整的 LaTeX 文档结构，包括根据其内部设置或默认值添加合适的 `\documentclass` 命令。如果在 `preamble` 中再次包含它，就会导致 "LaTeX Error: Two \documentclass or \documentstyle commands." (LaTeX 错误：存在两个 \documentclass 或 \documentstyle 命令) 的错误。

**总结:** 确保 `TexTemplate` 的 `preamble` 字符串*仅*包含宏包加载 (`\usepackage`) 和其他设置命令，*绝不*包含 `\documentclass`。

---

### 【Manim 代码生成规则：在调用 `clear_updaters()` 之前，要检查一个 Manim Mobject（包括 `VGroup`）是否有任何活动的 updater，**请勿使用** 名为 `has_updaters()` 的方法。该方法不存在，会导致 `AttributeError`】

**正确方法:**

使用 `Mobject.get_updaters()` 方法。该方法会返回一个包含当前附加到该 Mobject 上的 updater 函数的列表。检查这个列表是否非空（即检查其布尔真值）。

**示例 (正确用法):**

```python
my_mobject = Circle()
# ... (可能添加了 updater) ...
# my_mobject.add_updater(...)

# 正确的检查和清除方式:
if my_mobject.get_updaters(): # 检查 get_updaters() 返回的列表是否非空
    print("Mobject 存在 updater，正在清除。")
    my_mobject.clear_updaters()
else:
    print("Mobject 没有 updater。")
```

**原因:** 标准 Manim API 提供了 `get_updaters()` 来获取 updater 列表。检查返回列表的真值 (`if mobject.get_updaters():`) 是标准的 Pythonic 方式，用以判断它是否包含任何元素（即是否存在任何 updater）。

**总结:** 在调用 `mobject.clear_updaters()` 之前，请始终使用 `if mobject.get_updaters():` 来检查是否存在 updater。避免使用不存在的 `has_updaters()`。

---
### 【Manim 代码生成规则：禁止使用 `Mobject.set_color_gradient()` 方法】

**1. 问题描述:**
在 Manim Community (例如 v0.19.0) 中，尝试调用 `mobject.set_color_gradient(color1, color2)` 来为一个已创建的 Mobject 设置颜色渐变，会导致 `TypeError: Mobject.__getattr__.<locals>.setter() takes 2 positional arguments but 3 were given` 或类似的错误。

**2. 原因分析:**
`set_color_gradient()` 方法在较新版本的 Manim 中已被弃用或其工作方式已改变。直接调用它不再是设置渐变的推荐或有效方式。

**3. 正确做法（必须遵循）：**
*   **在初始化时设置:** 要为 `VMobject`（如 `Rectangle`, `Circle`, `Polygon` 等）应用填充或描边渐变，**必须**在创建该对象的构造函数（`__init__`）中，将一个包含所需颜色的**列表或元组**直接传递给 `fill_color` 或 `stroke_color` 关键字参数。
    ```python
    # 正确示例：在创建 Rectangle 时设置垂直填充渐变
    MY_COLOR_1 = BLUE
    MY_COLOR_2 = GREEN
    gradient_rect = Rectangle(
        width=4,
        height=2,
        stroke_width=0,
        fill_opacity=1,
        fill_color=[MY_COLOR_1, MY_COLOR_2] # <--- 正确方式：传递颜色列表
    )

    # 正确示例：设置描边渐变
    gradient_circle_stroke = Circle(
        radius=1,
        fill_opacity=0,
        stroke_width=5,
        stroke_color=(RED, YELLOW) # <--- 正确方式：传递颜色元组
    )
    ```
*   **默认方向:** 直接传递颜色列表/元组（例如 `[color1, color2]`）默认会创建**垂直**方向（从上到下，即 `DOWN`）的渐变。
*   **其他方向 (可选):** 如果需要非垂直方向的渐变，可以使用 `manim.utils.color.color_gradient` 函数来生成颜色列表，并指定 `direction` 参数，然后将结果传递给 `fill_color` 或 `stroke_color`。但**主要规则**是避免使用 `set_color_gradient` 方法。

**4. 禁止的做法:**
*   **绝对禁止**在 Mobject 创建之后调用 `mobject.set_color_gradient(color1, color2)`。

**5. 目标:**
确保生成的 Manim 代码使用当前推荐的、在对象初始化时通过 `fill_color` 或 `stroke_color` 参数传递颜色列表/元组的方式来创建颜色渐变，从而避免因调用已弃用或不兼容的 `set_color_gradient()` 方法而导致的 `TypeError`。


### 【Manim 代码生成规则：正确访问和清除 `fixed_in_frame_mobjects` (适用于 `ThreeDScene` 及子类)】

**1. 问题描述:**
在继承自 `ThreeDScene` 的场景类中（例如 `ThreeDScene` 或用户自定义的子类），尝试直接通过 `self.fixed_in_frame_mobjects` 访问或清除固定在屏幕上的 Mobject 列表，会导致 `AttributeError: 'YourSceneName' object has no attribute 'fixed_in_frame_mobjects'` 错误。

**2. 原因分析:**
在 `ThreeDScene` 及其子类中，管理固定在屏幕帧上的 Mobject 的列表是**相机对象 (`self.camera`)** 的责任。该列表不直接作为场景实例 (`self`) 的属性存在。

**3. 正确做法（必须遵循）：**
*   **访问列表:** 当需要获取或迭代固定在屏幕上的 Mobject 列表时，**必须**使用 `self.camera.fixed_in_frame_mobjects`。
*   **清除列表:** 当需要在场景切换或重置时清除所有固定在屏幕上的 Mobject 时，**必须**调用 `self.camera.fixed_in_frame_mobjects.clear()`。
*   **组合清除:** 在需要清除场景中*所有* Mobject（包括普通 3D 对象和固定屏幕对象）的函数（如 `clear_and_reset`）中，**必须**同时处理 `self.mobjects` 和 `self.camera.fixed_in_frame_mobjects`。

**4. 代码示例（在 `clear_and_reset` 函数中）：**

```python
def clear_and_reset(self):
    """Clears all mobjects (3D and fixed) and resets the camera."""

    # 正确：组合 self.mobjects 和 self.camera.fixed_in_frame_mobjects
    all_mobs_to_clear = list(self.mobjects) + list(self.camera.fixed_in_frame_mobjects)

    # 清除所有对象的 updaters
    for mob in all_mobs_to_clear:
        if mob is not None and hasattr(mob, 'get_updaters') and mob.get_updaters():
            mob.clear_updaters()

    # （可选）播放淡出动画
    valid_mobs = [m for m in all_mobs_to_clear if m is not None]
    if valid_mobs:
        self.play(FadeOut(Group(*valid_mobs)), run_time=0.5)

    # 清除场景的 3D 对象列表
    self.mobjects.clear()
    # 正确：清除相机的固定对象列表
    self.camera.fixed_in_frame_mobjects.clear()

    # 重置相机视角和状态
    self.set_camera_orientation(phi=0 * DEGREES, theta=-90 * DEGREES)
    self.move_camera(frame_center=ORIGIN, zoom=1.0, added_anims=[])

    self.wait(0.1)
```

**5. 目标:**
确保生成的代码在 `ThreeDScene` 或其子类中，始终通过 `self.camera.fixed_in_frame_mobjects` 来访问和操作固定在屏幕上的 Mobject 列表，从而避免因尝试访问不存在的 `self.fixed_in_frame_mobjects` 属性而导致的 `AttributeError`。

## 完整的python代码示例
```
# -*- coding: utf-8 -*-
import os
import numpy as np
import requests
from contextlib import contextmanager
from manim import *
import hashlib

from moviepy import AudioFileClip

# 自定义颜色
MY_DARK_BLUE = "#1E3A8A"  # 深蓝色
MY_LIGHT_GRAY = "#F3F4F6"  # 浅灰色
MY_MEDIUM_GRAY = "#D1D5DB"  # 中灰色
MY_GOLD = "#F59E0B"  # 金色
MY_ORANGE = "#F97316"  # 橙色
MY_RED = "#DC2626"  # 红色
MY_WHITE = "#FFFFFF"  # 白色
MY_BLACK = "#000000"  # 黑色

# --- TTS Caching Setup ---
CACHE_DIR = "tts_cache"
os.makedirs(CACHE_DIR, exist_ok=True)


class CustomVoiceoverTracker:
    """Tracks audio path and duration for TTS."""

    def __init__(self, audio_path, duration):
        self.audio_path = audio_path
        self.duration = duration


def get_cache_filename(text):
    """Generates a unique filename based on the text hash."""
    text_hash = hashlib.md5(text.encode('utf-8')).hexdigest()
    return os.path.join(CACHE_DIR, f"{text_hash}.mp3")


@contextmanager
def custom_voiceover_tts(text, token="123456", base_url="https://uni-ai.fly.dev/api/manim/tts"):
    """
    Fetches TTS audio, caches it, and provides path and duration.
    Usage: with custom_voiceover_tts("text") as tracker: ...
    """
    cache_file = get_cache_filename(text)
    audio_file = cache_file  # Initialize audio_file

    if os.path.exists(cache_file):
        audio_file = cache_file
        print(f"Using cached TTS for: {text[:30]}...")
    else:
        print(f"Requesting TTS for: {text[:30]}...")
        try:
            # URL encode the input text to handle special characters
            input_text_encoded = requests.utils.quote(text)
            url = f"{base_url}?token={token}&input={input_text_encoded}"

            response = requests.get(url, stream=True, timeout=60)  # Added timeout
            response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)

            with open(cache_file, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            audio_file = cache_file
            print("TTS downloaded and cached.")

        except requests.exceptions.RequestException as e:
            print(f"TTS API request failed: {e}")
            # Fallback: create a dummy tracker with zero duration
            tracker = CustomVoiceoverTracker(None, 0)
            yield tracker
            return  # Exit context manager

    # Ensure audio file exists before processing with MoviePy
    if audio_file and os.path.exists(audio_file):
        try:
            clip = AudioFileClip(audio_file)
            duration = clip.duration
            clip.close()
            print(f"Audio duration: {duration:.2f}s")
            tracker = CustomVoiceoverTracker(audio_file, duration)
        except Exception as e:
            print(f"Error processing audio file {audio_file}: {e}")
            # Fallback if audio file is corrupted or invalid
            tracker = CustomVoiceoverTracker(None, 0)
    else:
        # Fallback if audio file was not created or found
        print(f"TTS audio file not found or not created: {audio_file}")
        tracker = CustomVoiceoverTracker(None, 0)

    try:
        yield tracker
    finally:
        # No cleanup needed here as we are caching
        pass


# -----------------------------
# CombinedScene：整合所有场景并添加字幕和音频
# -----------------------------
class CombinedScene(MovingCameraScene):
    """
    合并所有场景的 Manim 动画，用于讲解如何求解函数 f(x)=x^2 的切线方程。
    """

    def construct(self):
        # Use a scene-specific time tracker for updaters if needed outside TTS timing
        self.scene_time_tracker = ValueTracker(0)

        # --- Play Scenes Sequentially ---
        self.play_scene_01()
        self.clear_and_reset()

        self.play_scene_02()
        self.clear_and_reset()

        self.play_scene_03()
        self.clear_and_reset()

        self.play_scene_04()
        self.clear_and_reset()

        self.play_scene_05()
        self.clear_and_reset()

        # End of animation message
        final_message = Text("动画结束，感谢观看！ 😄", font_size=48, color=MY_WHITE)
        bg_final = Rectangle(width=config.frame_width, height=config.frame_height, fill_color=MY_BLACK, fill_opacity=1,
                             stroke_width=0).set_z_index(-10)
        self.add(bg_final)
        self.play(FadeIn(final_message))
        self.wait(2)

    def get_scene_number(self, number_str):
        """创建并定位场景编号"""
        scene_num = Text(number_str, font_size=24, color=MY_WHITE)
        # Ensure the scene number is always within bounds
        scene_num.to_corner(UR, buff=0.3)  # Use smaller buff if needed
        scene_num.set_z_index(10)  # Ensure it's above background
        return scene_num

    def clear_and_reset(self):
        """清除当前场景所有对象并重置相机"""
        # Clear updaters explicitly from all mobjects
        for mob in self.mobjects:
            if mob is not None:
                mob.clear_updaters()

        # Use Group for potentially mixed object types
        valid_mobjects = [m for m in self.mobjects if m is not None]
        all_mobjects = Group(*valid_mobjects)

        if all_mobjects:
            # Fade out existing objects
            self.play(FadeOut(all_mobjects, shift=DOWN * 0.5), run_time=0.5)

        # Clear the scene's mobject list
        self.clear()

        # Reset camera position and scale
        self.camera.frame.move_to(ORIGIN)
        # Ensure frame dimensions match configuration
        self.camera.frame.set(width=config.frame_width, height=config.frame_height)
        # Reset camera orientation (important if rotations were applied)
        # For MovingCameraScene, resetting scale and position is usually enough.
        # If explicit rotation was done: self.camera.frame.set(rotation=0) - check API if needed

        # Reset the custom time tracker
        self.scene_time_tracker.set_value(0)
        self.wait(0.1)  # Short pause after reset

    def star_updater(self, star, dt):
        """更新星星透明度，实现闪烁效果 (Uses scene_time_tracker)"""
        # Retrieve stored parameters or use defaults
        base_opacity = getattr(star, "base_opacity", 0.5)
        frequency = getattr(star, "frequency", 0.5)
        phase = getattr(star, "phase", 0)

        current_time = self.scene_time_tracker.get_value()
        # Calculate opacity based on sine wave
        opacity_variation = 0.4 * np.sin(2 * PI * frequency * current_time + phase)
        target_opacity = np.clip(base_opacity + opacity_variation, 0.1, 0.9)  # Clamp opacity

        # Apply the calculated opacity
        # Use set_opacity which handles both fill and stroke
        star.set_opacity(target_opacity)

        # Manually update the scene time tracker
        self.scene_time_tracker.increment_value(dt)

    # --- Scene 1: Welcome & Starry Background ---
    def play_scene_01(self):
        """场景一：欢迎介绍与星空背景"""
        self.scene_time_tracker.set_value(0)  # Reset time for this scene

        # Background
        bg1 = Rectangle(
            width=config.frame_width,
            height=config.frame_height,
            fill_color=MY_DARK_BLUE,
            fill_opacity=1.0,
            stroke_width=0
        )
        bg1.set_z_index(-10)
        self.add(bg1)

        # Stars
        stars = VGroup()
        num_stars = 200
        for _ in range(num_stars):
            x_pos = np.random.uniform(-config.frame_width / 2 * 0.95, config.frame_width / 2 * 0.95)
            y_pos = np.random.uniform(-config.frame_height / 2 * 0.95, config.frame_height / 2 * 0.95)
            star_dot = Dot(point=[x_pos, y_pos, 0], radius=0.02, color=MY_WHITE)
            # Store custom data directly on the mobject
            star_dot.base_opacity = np.random.uniform(0.3, 0.7)
            star_dot.frequency = np.random.uniform(0.3, 0.8)
            star_dot.phase = np.random.uniform(0, 2 * PI)
            # Set initial opacity using the method, not constructor
            star_dot.set_opacity(star_dot.base_opacity)
            stars.add(star_dot)

        # Add the updater to the stars group
        stars.add_updater(self.star_updater)
        self.add(stars)

        # Scene Number
        scene_num_01 = self.get_scene_number("01")
        self.add(scene_num_01)

        # Title and Subtitle
        title = Text("大家好，欢迎来到本期数学讲解视频 👋", font_size=48, color=MY_WHITE)
        title.move_to(UP * 2.5)  # Position using move_to or shift

        subtitle_part1 = Text("如何求解函数", font_size=36, color=MY_WHITE)
        subtitle_part2 = MathTex("f(x)=x^2", font_size=42, color=MY_ORANGE)
        subtitle_part3 = Text("的切线方程 🤔", font_size=36, color=MY_WHITE)
        subtitle = VGroup(subtitle_part1, subtitle_part2, subtitle_part3).arrange(RIGHT, buff=0.2)
        subtitle.next_to(title, DOWN, buff=0.5)

        # --- TTS Integration ---
        voice_text_01 = "大家好，欢迎来到本期数学讲解视频。👋 本期我们将讲解如何求解函数 f(x) 等于 x 平方的切线方程。🤔"
        with custom_voiceover_tts(voice_text_01) as tracker:
            # Check if audio is available
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 1 TTS audio failed or has zero duration.")
                # If TTS fails, we'll just run the animations without sound sync

            # Subtitle for the voiceover
            subtitle_voice = Text(
                voice_text_01,
                font_size=32,
                color=MY_WHITE,
                # Use width for automatic line breaking
                width=config.frame_width - 2,
                should_center=True  # Center multi-line text
            ).to_edge(DOWN, buff=0.5)

            # Animation sequence synchronized with TTS (if available)
            anim_runtime_title = 1.5
            anim_runtime_subtitle = 2.0
            fade_out_duration = 1.0
            total_anim_duration_planned = anim_runtime_title + anim_runtime_subtitle

            # Animation Group 1: Title + Subtitle Voice Fade In
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice, run_time=0.5),  # Quick fade in for subtitle
                    FadeIn(title, shift=UP * 0.5, run_time=anim_runtime_title),
                    lag_ratio=0.0  # Start simultaneously
                ),
                run_time=anim_runtime_title  # Overall duration for this group
            )

            # Animation Group 2: Subtitle parts appear
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_part1, shift=RIGHT * 0.2),
                    Write(subtitle_part2),  # MathTex uses Write
                    FadeIn(subtitle_part3, shift=LEFT * 0.2),
                    lag_ratio=0.2  # Slight delay between parts
                ),
                run_time=anim_runtime_subtitle
            )

            # Calculate wait time based on audio duration vs animation time
            if tracker.duration > 0:
                # Time already spent in animations
                elapsed_time = total_anim_duration_planned
                # Time needed for fade out at the end
                time_for_fadeout = fade_out_duration
                # Calculate remaining time to wait
                remaining_time = tracker.duration - elapsed_time - time_for_fadeout
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                # If no audio, just wait a bit after animations
                self.wait(1.0)

            # Fade out the voiceover subtitle
            self.play(FadeOut(subtitle_voice), run_time=fade_out_duration)

        # Keep stars and title/subtitle visible for a moment before clearing
        self.wait(1)

    # --- Scene 2: Tangent Concept & Problem Background ---
    def play_scene_02(self):
        """场景二：切线概念与问题背景介绍"""
        self.scene_time_tracker.set_value(0)  # Reset time

        # Background
        bg2 = Rectangle(
            width=config.frame_width, height=config.frame_height,
            fill_color=MY_LIGHT_GRAY, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg2)

        # Scene Number
        scene_num_02 = self.get_scene_number("02")
        self.add(scene_num_02)

        # Layout: Left Text, Right Graph
        left_margin = LEFT * (config.frame_width / 4)
        right_margin = RIGHT * (config.frame_width / 4)

        # Left Text explanation
        text_lines = VGroup(
            Text("切线概念：", font_size=36, color=MY_BLACK, weight=BOLD),
            Text("切线是曲线在某一点的瞬时方向。", font_size=30, color=MY_BLACK),
            # Combine Text and MathTex for inline formula
            VGroup(
                Text("对于函数 ", font_size=30, color=MY_BLACK),
                MathTex("f(x)=x^2", font_size=36, color=MY_ORANGE),
                Text("，", font_size=30, color=MY_BLACK),
            ).arrange(RIGHT, buff=0.15),
            Text("切线反映了曲线在该点的斜率变化。", font_size=30, color=MY_BLACK),
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.3)
        text_lines.move_to(left_margin + UP * 1.0)  # Position on the left

        # Right Graph
        axes = Axes(
            x_range=[-3, 3, 1],
            y_range=[0, 9, 1],
            x_length=6,
            y_length=5,
            # IMPORTANT: Hide central axes to avoid "cross"
            x_axis_config={"stroke_width": 2, "color": MY_BLACK, "include_tip": True},
            y_axis_config={"stroke_width": 2, "color": MY_BLACK, "include_tip": True},
            axis_config={"color": MY_BLACK, "stroke_width": 2},
            tips=False,  # Hide tips if specified in axis_config
        ).move_to(right_margin + DOWN * 0.5)  # Position on the right

        # Hide the zero lines of the axes themselves if they overlay grid lines
        # This is usually done by setting stroke_width to 0 in axis_config,
        # but we want visible axes, just not the implicit lines at x=0, y=0 if they look odd.
        # If using NumberPlane, you'd hide center lines there. For Axes, usually ok.

        # Function and Plot
        func = lambda x: x ** 2
        parabola = axes.plot(func, color=MY_ORANGE, stroke_width=3)
        parabola_label = axes.get_graph_label(parabola, label='f(x)=x^2', x_val=2, direction=UR)
        # Set font size after creation for graph labels
        parabola_label.set_color(MY_ORANGE)
        parabola_label.set_font_size(30)

        # Tangent Point
        a = 1
        tangent_point_coord = axes.c2p(a, func(a))  # Convert graph coords to screen coords
        tangent_point_dot = Dot(tangent_point_coord, color=MY_RED, radius=0.1)
        tangent_point_label = MathTex("(a, a^2)", font_size=30, color=MY_RED)
        tangent_point_label.next_to(tangent_point_dot, DR, buff=0.1)

        # Pulsing animation for the dot (simple scale pulse)
        # We'll use an animation loop instead of an updater here for simplicity
        dot_pulse_anim = Succession(
            ApplyMethod(tangent_point_dot.scale, 1.3, rate_func=there_and_back, run_time=1.0),
            Wait(0.5)
        )

        # --- TTS Integration ---
        voice_text_02 = "首先我们来理解切线的概念。切线就是曲线在某一点的瞬时方向。对于我们研究的函数 f(x) 等于 x 平方，它的图像是一条抛物线。我们关注的是如何找到这条抛物线上任意一点，比如点 (a, a平方) 处的切线。"
        with custom_voiceover_tts(voice_text_02) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 2 TTS audio failed or has zero duration.")

            subtitle_voice_02 = Text(
                voice_text_02, font_size=32, color=MY_BLACK,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Staggered animation appearance
            self.play(
                AnimationGroup(
                    FadeIn(subtitle_voice_02, run_time=0.5),
                    # Create Axes and Parabola first
                    Create(axes, run_time=2.0),
                    Create(parabola, run_time=2.0),
                    lag_ratio=0.0  # Start subtitle and graph creation together
                ),
                run_time=2.0
            )
            # Then fade in text and labels
            self.play(
                AnimationGroup(
                    FadeIn(text_lines, shift=UP * 0.5, lag_ratio=0.1),  # Fade in text lines
                    Write(parabola_label),  # Write graph label
                    lag_ratio=0.3  # Slight lag between text and label
                ),
                run_time=2.5
            )
            # Finally, show the tangent point
            self.play(
                GrowFromCenter(tangent_point_dot),
                Write(tangent_point_label),
                run_time=1.0
            )

            # Play the dot pulse animation while text/graph is shown
            self.play(dot_pulse_anim)  # Run the pulsing animation once

            # Calculate wait time
            elapsed_time = 2.0 + 2.5 + 1.0 + dot_pulse_anim.get_run_time()
            if tracker.duration > 0:
                remaining_time = tracker.duration - elapsed_time - 1.0  # Subtract fade out time
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.0)  # Wait if no audio

            # Fade out subtitle
            self.play(FadeOut(subtitle_voice_02), run_time=1.0)

        self.wait(1)

    # --- Scene 3: Solving Steps ---
    def play_scene_03(self):
        """场景三：切线求解步骤展示"""
        self.scene_time_tracker.set_value(0)

        # Background (Light gray, maybe with faint grid)
        bg3 = Rectangle(
            width=config.frame_width, height=config.frame_height,
            fill_color=MY_LIGHT_GRAY, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg3)

        # Optional faint grid using NumberPlane
        grid = NumberPlane(
            x_range=[-10, 10, 1], y_range=[-6, 6, 1],
            x_length=config.frame_width, y_length=config.frame_height,
            background_line_style={
                "stroke_color": MY_MEDIUM_GRAY,
                "stroke_width": 1,
                "stroke_opacity": 0.3  # Faint grid lines
            },
            # Hide axis labels and thick center lines of the grid itself
            axis_config={"stroke_width": 0},
            x_axis_config={"stroke_width": 0},
            y_axis_config={"stroke_width": 0},
        ).set_z_index(-9)  # Behind content but above background
        self.add(grid)

        # Scene Number
        scene_num_03 = self.get_scene_number("03")
        self.add(scene_num_03)

        # Layout: Left Steps, Right Graph
        left_margin = LEFT * (config.frame_width / 4)
        right_margin = RIGHT * (config.frame_width / 4)

        # Left: Step-by-step derivation
        steps_title = Text("求解步骤:", font_size=36, color=MY_BLACK, weight=BOLD).to_corner(UL, buff=1.0).shift(
            right_margin * 0.1)  # Adjust position

        # Combine Text (Chinese) and MathTex (Formula) for each step
        step1 = VGroup(Text("1. 确定切点: ", font_size=30, color=MY_BLACK),
                       MathTex("(a, a^2)", font_size=32, color=MY_ORANGE)).arrange(RIGHT, buff=0.15)
        step2 = VGroup(Text("2. 求导数和斜率: ", font_size=30, color=MY_BLACK),
                       MathTex("f'(x)=2x, \\quad f'(a)=2a", font_size=32, color=MY_ORANGE)).arrange(RIGHT, buff=0.15)
        step3 = VGroup(Text("3. 写出点斜式: ", font_size=30, color=MY_BLACK),
                       MathTex("y - a^2 = 2a(x - a)", font_size=32, color=MY_ORANGE)).arrange(RIGHT, buff=0.15)
        step4 = VGroup(Text("4. 整理得切线方程: ", font_size=30, color=MY_BLACK),
                       MathTex("y = 2a(x - a) + a^2", font_size=32, color=MY_ORANGE)).arrange(RIGHT, buff=0.15)

        steps_vg = VGroup(step1, step2, step3, step4).arrange(DOWN, aligned_edge=LEFT, buff=0.4)
        steps_vg.next_to(steps_title, DOWN, aligned_edge=LEFT, buff=0.5)
        steps_vg.move_to(left_margin + UP * 0.5)  # Adjust vertical position

        # Right: Graph Visualization
        axes_step3 = Axes(
            x_range=[-3, 3, 1], y_range=[0, 9, 1],
            x_length=6, y_length=5,
            x_axis_config={"stroke_width": 2, "color": MY_BLACK},
            y_axis_config={"stroke_width": 2, "color": MY_BLACK},
            axis_config={"color": MY_BLACK, "include_tip": False},
            tips=False,
        ).move_to(right_margin + DOWN * 0.5)

        func = lambda x: x ** 2
        parabola_step3 = axes_step3.plot(func, color=MY_ORANGE, stroke_width=3)

        a = 1  # Specific value for visualization
        slope = 2 * a
        tangent_point_coord_step3 = axes_step3.c2p(a, func(a))
        tangent_point_dot_step3 = Dot(tangent_point_coord_step3, color=MY_RED, radius=0.08)  # Slightly smaller dot

        # Tangent Line Calculation (using plot for simplicity)
        tangent_line_func = lambda x: slope * (x - a) + func(a)
        tangent_line = axes_step3.plot(
            tangent_line_func,
            color=MY_GOLD,  # Use Gold for tangent line
            stroke_width=3,
            x_range=[a - 1.5, a + 1.5]  # Limit line length for clarity
        )
        tangent_label = axes_step3.get_graph_label(tangent_line, label='y = 2a(x-a)+a^2', direction=DOWN)
        tangent_label.set_color(MY_GOLD)
        tangent_label.set_font_size(24)  # Smaller font for line label

        # --- TTS Integration ---
        voice_text_03 = "现在我们来一步步求解。第一步，确定切点，就是抛物线上的点 (a, a平方)。第二步，计算函数 f(x) 的导数，得到 f'(x) 等于 2x。那么在点 a 处的斜率就是 f'(a) 等于 2a。第三步，利用点斜式方程，我们可以写出切线的初步形式：y 减 a平方 等于 2a 乘以 (x 减 a)。最后，第四步，整理这个方程，就得到了最终的切线方程：y 等于 2a 乘以 (x 减 a) 再加上 a平方。看右边的图形，当 a=1 时，切点是 (1,1)，斜率是 2，这就是对应的切线。"
        with custom_voiceover_tts(voice_text_03) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 3 TTS audio failed or has zero duration.")

            subtitle_voice_03 = Text(
                voice_text_03, font_size=32, color=MY_BLACK,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            # Show subtitle and initial elements
            self.play(FadeIn(subtitle_voice_03, run_time=0.5))
            self.play(
                FadeIn(steps_title),
                Create(axes_step3),
                Create(parabola_step3),
                GrowFromCenter(tangent_point_dot_step3),
                run_time=2.0
            )

            # Animate steps appearing one by one, synchronized with rough timing
            self.play(FadeIn(step1[0]), Write(step1[1]), run_time=1.5)  # Step 1
            self.wait(1.0)  # Pause slightly between steps
            self.play(FadeIn(step2[0]), Write(step2[1]), run_time=2.0)  # Step 2
            self.wait(1.0)
            self.play(FadeIn(step3[0]), Write(step3[1]), run_time=2.5)  # Step 3
            # Show tangent line when step 3/4 appears
            self.play(Create(tangent_line), Write(tangent_label), run_time=2.0)
            self.wait(0.5)
            self.play(FadeIn(step4[0]), Write(step4[1]), run_time=2.5)  # Step 4

            # Adjust wait time based on audio duration
            anim_time = 2.0 + 1.5 + 1.0 + 2.0 + 1.0 + 2.5 + 2.0 + 0.5 + 2.5  # Approximate animation time
            if tracker.duration > 0:
                remaining_time = tracker.duration - anim_time - 1.0  # Subtract fade out time
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.0)  # Wait if no audio

            self.play(FadeOut(subtitle_voice_03), run_time=1.0)

        self.wait(1)

    # --- Scene 4: Theoretical Principles ---
    def play_scene_04(self):
        """场景四：理论原理与数学公式解析"""
        self.scene_time_tracker.set_value(0)

        # Background (Medium Gray)
        bg4 = Rectangle(
            width=config.frame_width, height=config.frame_height,
            fill_color=MY_MEDIUM_GRAY, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg4)

        # Scene Number
        scene_num_04 = self.get_scene_number("04")
        self.add(scene_num_04)

        # Camera intro rotation (optional)
        # self.play(self.camera.frame.animate.rotate(10 * DEGREES, axis=OUT), run_time=1.0)
        # self.play(self.camera.frame.animate.move_to(ORIGIN).rotate(-10 * DEGREES, axis=OUT), run_time=1.0) # Rotate back and center

        # Top: Derivative Definition Formula
        deriv_title = Text("核心原理 1: 导数定义", font_size=32, color=MY_BLACK, weight=BOLD)
        deriv_formula = MathTex(
            r"f'(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h}",
            font_size=48, color=MY_DARK_BLUE
        )
        deriv_group = VGroup(deriv_title, deriv_formula).arrange(DOWN, buff=0.3)
        deriv_group.move_to(UP * 2.0)  # Position top-center

        # Bottom: Point-Slope Form Formula
        point_slope_title = Text("核心原理 2: 点斜式方程", font_size=32, color=MY_BLACK, weight=BOLD)
        point_slope_formula = MathTex(
            r"y - y_1 = m(x - x_1)",
            font_size=48, color=MY_DARK_BLUE
        )
        point_slope_group = VGroup(point_slope_title, point_slope_formula).arrange(DOWN, buff=0.3)
        point_slope_group.move_to(DOWN * 2.0)  # Position bottom-center

        # Arrow connecting the concepts
        # Use Create for arrow animation
        arrow = Arrow(
            deriv_formula.get_bottom() + DOWN * 0.2,  # Start below deriv formula
            point_slope_group.get_top() + UP * 0.2,  # End above point-slope group
            buff=0.1,
            color=MY_GOLD,
            stroke_width=6,
            max_tip_length_to_length_ratio=0.15,  # Adjust arrow tip size
        )

        # --- TTS Integration ---
        voice_text_04 = "回顾一下背后的数学原理。我们计算斜率 2a，是基于导数的定义，它描述了函数在某点变化的快慢。而我们写出最终的切线方程，是利用了直线的点斜式方程，其中 (x1, y1) 就是我们的切点 (a, a平方)，m 就是我们求出的斜率 2a。这两个是求解切线问题的关键理论基础。"
        with custom_voiceover_tts(voice_text_04) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 4 TTS audio failed or has zero duration.")

            subtitle_voice_04 = Text(
                voice_text_04, font_size=32, color=MY_BLACK,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)

            self.play(FadeIn(subtitle_voice_04, run_time=0.5))

            # Animate formulas and arrow
            self.play(
                FadeIn(deriv_group, shift=UP * 0.5),
                run_time=2.0
            )
            self.wait(1.0)  # Pause before showing the next part
            self.play(
                FadeIn(point_slope_group, shift=DOWN * 0.5),
                run_time=2.0
            )
            self.wait(0.5)
            # Use Create for the arrow
            self.play(Create(arrow), run_time=1.5)

            # Highlight key parts (optional)
            # self.play(Indicate(deriv_formula.get_part_by_tex("f'(x)")), color=MY_RED)
            # self.play(Indicate(point_slope_formula.get_part_by_tex("m")), color=MY_RED)

            # Calculate wait time
            anim_time = 0.5 + 2.0 + 1.0 + 2.0 + 0.5 + 1.5  # Animation time
            if tracker.duration > 0:
                remaining_time = tracker.duration - anim_time - 1.0  # Subtract fade out time
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.0)  # Wait if no audio

            self.play(FadeOut(subtitle_voice_04), run_time=1.0)

        self.wait(1)

    # --- Scene 5: Summary & Review ---
    def play_scene_05(self):
        """场景五：总结与回顾"""
        self.scene_time_tracker.set_value(0)

        # Background (Dark Blue or Black)
        bg5 = Rectangle(
            width=config.frame_width, height=config.frame_height,
            fill_color=MY_BLACK, fill_opacity=1.0, stroke_width=0
        ).set_z_index(-10)
        self.add(bg5)

        # Scene Number
        scene_num_05 = self.get_scene_number("05")
        self.add(scene_num_05)

        # Summary Title
        summary_title = Text("总结 ✨", font_size=48, color=MY_GOLD, weight=BOLD)
        summary_title.to_edge(UP, buff=1.0)

        # Key formulas
        point_formula = MathTex("(a, a^2)", font_size=40, color=MY_WHITE)
        point_label = Text("切点: ", font_size=36, color=MY_WHITE)
        point_group = VGroup(point_label, point_formula).arrange(RIGHT, buff=0.2)

        deriv_result = MathTex("f'(x)=2x, \\quad f'(a)=2a", font_size=40, color=MY_WHITE)
        deriv_label = Text("导数与斜率: ", font_size=36, color=MY_WHITE)
        deriv_group = VGroup(deriv_label, deriv_result).arrange(RIGHT, buff=0.2)

        tangent_eq = MathTex("y = 2a(x - a) + a^2", font_size=40, color=MY_WHITE)
        tangent_label = Text("切线方程: ", font_size=36, color=MY_WHITE)
        tangent_group = VGroup(tangent_label, tangent_eq).arrange(RIGHT, buff=0.2)

        # Arrange summary items vertically
        summary_formulas = VGroup(point_group, deriv_group, tangent_group).arrange(DOWN, aligned_edge=LEFT, buff=0.6)
        summary_formulas.next_to(summary_title, DOWN, buff=0.8)

        # Question at the bottom
        question = Text("思考 🤔：你认为切线方程还能帮助我们解决哪些类型的问题？", font_size=32, color=MY_LIGHT_GRAY)
        question.to_edge(DOWN, buff=1.0)

        # --- TTS Integration ---
        voice_text_05 = "好了，让我们来总结一下。要求函数 f(x) 等于 x 平方的切线方程，你需要记住三个关键点：一是切点坐标 (a, a平方)，二是导数 f'(x) 等于 2x，由此得到切点斜率 2a，三是最终的切线方程 y 等于 2a 乘以 (x 减 a) 加上 a平方。希望通过本期视频，你已经掌握了这个方法！思考一下，切线方程在数学或其他领域还有哪些应用呢？"
        with custom_voiceover_tts(voice_text_05) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path, time_offset=0)
            else:
                print("Warning: Scene 5 TTS audio failed or has zero duration.")

            subtitle_voice_05 = Text(
                voice_text_05, font_size=32, color=MY_WHITE,
                width=config.frame_width - 2, should_center=True
            ).to_edge(DOWN, buff=0.5)  # Place above the final question maybe?
            # Let's place the fixed question first, then the voice subtitle above it
            subtitle_voice_05.next_to(question, UP, buff=0.3)

            # Animations
            self.play(FadeIn(summary_title), run_time=1.0)
            self.play(FadeIn(subtitle_voice_05, run_time=0.5))  # Show subtitle early

            # Reveal formulas one by one
            self.play(FadeIn(point_group, shift=LEFT * 0.2), run_time=1.5)
            self.wait(0.5)
            self.play(FadeIn(deriv_group, shift=LEFT * 0.2), run_time=1.5)
            self.wait(0.5)
            self.play(FadeIn(tangent_group, shift=LEFT * 0.2), run_time=1.5)
            self.wait(1.0)  # Pause on formulas

            # Show the final question
            self.play(FadeIn(question, shift=UP * 0.2), run_time=1.5)

            # Camera Zoom In
            self.play(self.camera.frame.animate.scale(1.1), run_time=1.5)  # Slight zoom for focus

            # Calculate wait time
            anim_time = 1.0 + 0.5 + 1.5 + 0.5 + 1.5 + 0.5 + 1.5 + 1.0 + 1.5 + 1.5  # Animation time
            if tracker.duration > 0:
                remaining_time = tracker.duration - anim_time - 1.0  # Subtract fade out time
                if remaining_time > 0:
                    self.wait(remaining_time)
            else:
                self.wait(1.0)  # Wait if no audio

            self.play(FadeOut(subtitle_voice_05), run_time=1.0)

        self.wait(2)  # Hold the final summary screen


# --- Main execution block ---
if __name__ == "__main__":
    # Basic configuration
    config.pixel_height = 1080  # Set resolution height
    config.pixel_width = 1920  # Set resolution width
    config.frame_rate = 30  # Set frame rate
    config.output_file = "CombinedScene"  # Specify output filename
    config.disable_caching = True  # Disable caching

    # Set output directory using placeholder for Java replacement
    config.media_dir = r"#(output_path)"  # IMPORTANT: Use the placeholder

    # Create and render the scene
    scene = CombinedScene()
    scene.render()

    print(f"Scene rendering finished. Output in: {config.media_dir}")
```

我的版本是 Manim Community v0.19.0.请输出完整的 Python 代码。