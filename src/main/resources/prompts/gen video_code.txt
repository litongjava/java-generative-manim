请基于以下详细场景提示，生成完整的 Manim Community 版 Python 代码。代码应满足以下要求：

1. **动画元素与输出要求：**
   - 最终生成一个完整的视频，所有场景连续合成在一个视频中；
   - 包含所有预期的动画元素，包括背景、数学公式、动画效果、相机运动和颜色变化。

2. **数学公式与文本显示：**
   - 所有数学公式使用 LaTeX 格式编写且正确显示；
   - 任何中文文本请使用 `Text`（或使用 `Tex` 搭配 XeLaTeX 模板），**不要直接放在 `MathTex` 中**，以避免 LaTeX 编译 Unicode 错误。

3. **代码结构与调试要求：**
   - 代码应遵循 Manim Community 版的编写规范，结构清晰、模块化，便于后续调试和修改；
   - 代码中应包含必要的注释，解释每个主要部分的作用和实现思路。

4. **关于动画效果与细节：**
   - 在创建星星时，**不要在 `Dot` 构造函数中传入 `opacity`**；应使用 `.set_opacity()` 方法单独设置透明度。
   - 在创建三维坐标系时，**不要在 `axis_config` 中使用 `opacity`**；如果需要调整透明度，请使用 `stroke_opacity` 参数或在生成后对返回的 `ThreeDAxes` 对象调用 `.set_opacity()`。
   - 在引用颜色常量（例如 `SILVER`）时，请从 `manim` 顶层直接导入（如 `from manim import SILVER`），而非深层路径。

5. **背景、场景编号与坐标一致性：**
   - 每个场景都必须使用摄像机的 `frame_width` 和 `frame_height`（或适当加上边距）来创建背景，确保背景完全覆盖屏幕；
   - 每个场景都创建一个与屏幕对齐的矩形作为背景.bg4 = Rectangle(width=self.camera.frame_width,height=self.camera.frame_height)
   - 使用 `bg.set_z_index(-1)` 将背景置于最底层，防止遮挡其它元素（如场景编号）；
   - 对于含有 NumberPlane 的场景（例如场景04），请通过设置 `x_axis_config={"stroke_width": 0}` 和 `y_axis_config={"stroke_width": 0}` 来隐藏中轴线，避免出现不应有的“十字架”。
   - 场景编号标签（例如 "01"、"02"、"03"、"04"、"05"）应放置在屏幕右上角，使用如 `to_corner(UR, buff=0.5)` 的方法，确保始终在屏幕内显示，不超出边界。

6. **场景合成与清除问题：**
   - 当将多个独立场景合并为一个连续的动画时，必须确保前一部分内容不会残留到后续场景中。
   - 请在每个部分结束时使用 `FadeOut(Group(*self.mobjects))` 和 `self.clear()` 来清除当前所有对象，并重置相机帧尺寸（例如 `self.camera.frame.set(width=self.camera.frame_width, height=self.camera.frame_height)`) 以保证各场景之间的坐标系统一致。

7. **错误与问题总结（需在提示中包含）：**
   - **未定义常量问题**：避免使用未定义的 `FRAME_WIDTH` 和 `FRAME_HEIGHT`，改为使用 `self.camera.frame_width` 和 `self.camera.frame_height`。
   - **相机属性问题**：在需要动画相机帧时请继承 `MovingCameraScene` 而非普通 `Scene`。
   - **切线绘制方法问题**：避免使用 `axes.get_line_from_point_slope` 时传入错误的关键字参数；请改为手动计算切线端点并使用 `Line` 对象绘制切线。
   - **组对象处理问题**：当清除所有对象时，避免使用 `VGroup(*self.mobjects)`（可能包含非 `VMobject` 对象），建议使用 `Group(*self.mobjects)`。
   - **场景合成与内容残留问题**：合并多个场景时需在每个部分结束后清除前一部分的所有对象并重置相机，确保后续场景不会受到影响。
   - **背景覆盖与层级问题**：确保每个场景背景的尺寸足以完全覆盖屏幕，并通过设置 `set_z_index(-1)` 保证背景不会遮挡其他元素；同时调整场景编号的位置以避免超出屏幕。
   - **NumberPlane 显示问题**：为避免出现不必要的中轴线（“十字架”），请在配置 NumberPlane 时将 x 轴和 y 轴的 `stroke_width` 设置为 0。

8. **最终生成一个视频**：
   - 所有场景应合并为一个连续的动画，生成一个完整的视频文件，确保各场景之间过渡流畅且内容不会相互干扰。
   - 设置"media_dir": "./#(output_video)", java程序会对#(output_video)进行替换
   - 场景名称必须是CombinedScene,因为需要生成 CombinedScene.mp4文件
   - 需要添加main方法,因为我是使用python运行这个命令

9. 请使用用户的消息语言作为输出语言。

我的版本是 Manim Community v0.19.0.请输出完整的 Python 代码。

python代码示例
已知函数f(x)=x^2,如何求解该函数的切线
```python
from manim import *
import numpy as np
from manim.mobject.geometry.tips import ArrowSquareTip

class CosmicProbabilityScene(ThreeDScene):
    def construct(self):
        self.setup_initial_scene()
        self.animate_cosmic_distributions()
        self.create_diffusion_bridge()
        self.show_optimal_transport()
        self.demonstrate_wasserstein()
        self.synthesize_benamou_brenier()
        
    def setup_initial_scene(self):
        self.camera.background_color = BLACK
        self.cosmic_void = Rectangle(
            width=config.frame_width,
            height=config.frame_height,
            fill_color=BLACK,
            fill_opacity=1,
            stroke_width=0
        )
        self.add(self.cosmic_void)
        
    def animate_cosmic_distributions(self):
        # Scene 1: Cosmic Distributions
        title_group = VGroup(
            Text("Diffusion Models", gradient=(BLUE, TEAL)),
            Text("Optimal Transport", gradient=(GOLD, ORANGE)),
            Text("Benamou-Brenier Theorem", gradient=(PURPLE, RED)),
            Text("Wasserstein Distance", gradient=(GREEN, YELLOW)),
        ).arrange(DOWN, buff=0.3).scale(0.8)
        
        self.play(
            Write(title_group),
            run_time=3,
            rate_func=smooth
        )
        self.wait(2)
        self.play(FadeOut(title_group))
        
        # Create spiral galaxies with different structures
        self.alpha0_dict = self.create_spiral_galaxy(
            spiral_arms=3, 
            particle_color=BLUE, 
            label=r"\alpha_0", 
            position=LEFT*3,
            arm_tightness=0.4
        )
        self.alpha1_dict = self.create_spiral_galaxy(
            spiral_arms=2, 
            particle_color=GOLD, 
            label=r"\alpha_1", 
            position=RIGHT*3,
            arm_tightness=0.6,
            rotation=PI/3
        )
        
        self.play(
            SpiralIn(self.alpha0_dict["particles"]),
            SpiralIn(self.alpha1_dict["particles"]),
            run_time=4
        )
        self.wait()
        
        # Add distribution labels with arrows
        alpha0_label = MathTex(r"\alpha_0 \text{ (Initial Distribution)}", color=BLUE)
        alpha1_label = MathTex(r"\alpha_1 \text{ (Target Distribution)}", color=GOLD)
        alpha0_label.next_to(self.alpha0_dict["particles"], DOWN)
        alpha1_label.next_to(self.alpha1_dict["particles"], DOWN)
        
        self.play(
            GrowFromCenter(alpha0_label),
            GrowFromCenter(alpha1_label),
            self.alpha0_dict["particles"].animate.set_opacity(0.7),
            self.alpha1_dict["particles"].animate.set_opacity(0.7)
        )
        self.wait(2)
        
    def create_spiral_galaxy(self, spiral_arms=2, particle_color=BLUE, 
                            label="", position=ORIGIN, arm_tightness=0.5,
                            rotation=0):
        galaxy_dict = {}
        galaxy = VGroup()
        n_particles = 1000  # Number of particles in the galaxy
        
        # Spiral parametric equations
        particles = VGroup()
        for i in range(n_particles):
            theta = TAU * np.random.rand()
            r = np.random.exponential(scale=2)
            x = r * np.cos(theta + rotation) + arm_tightness * np.cos(spiral_arms * theta)
            y = r * np.sin(theta + rotation) + arm_tightness * np.sin(spiral_arms * theta)
            particle = Dot(
                point=[x, y, 0],
                color=particle_color,
                radius=0.03 * np.random.normal(loc=1, scale=0.3),
                fill_opacity=0.8 * np.random.rand()
            )
            particles.add(particle)
        
        galaxy_dict["particles"] = particles
        galaxy.add(particles)
        galaxy.move_to(position)
        
        # Add rotating glow effect
        glow = Annulus(
            inner_radius=0.5,
            outer_radius=2,
            color=particle_color,
            fill_opacity=0.2
        ).rotate(rotation)
        galaxy_dict["glow"] = glow
        galaxy.add(glow)
        
        # Add label with custom arrow
        label_tex = MathTex(label, color=particle_color).scale(1.2)
        label_tex.next_to(galaxy, UP)
        arrow = CurvedArrow(
            label_tex.get_bottom(),
            galaxy.get_center(),
            color=particle_color,
            tip_shape=ArrowSquareTip
        )
        galaxy_dict["label"] = label_tex
        galaxy_dict["arrow"] = arrow
        galaxy.add(label_tex, arrow)
        
        return galaxy_dict

    def create_diffusion_bridge(self):
        # Scene 2: Blending Nebula
        t_tracker = ValueTracker(0)
        bridge = always_redraw(lambda: self.generate_bridge(
            self.alpha0_dict["particles"],
            self.alpha1_dict["particles"],
            t_tracker.get_value()
        ))
        
        # Create time indicator with label
        time_indicator = NumberLine(
            x_range=[0, 1, 0.1],
            length=6,
            include_numbers=True
        ).to_edge(DOWN)
        time_label = Text("Time t").next_to(time_indicator, DOWN)
        time_indicator_group = VGroup(time_indicator, time_label)
        
        time_dot = Dot(color=YELLOW).add_updater(
            lambda m: m.move_to(time_indicator.n2p(t_tracker.get_value()))
        )
        
        equation = MathTex(
            r"\alpha_t = ((1 - t)P_0 + tP_1)_{\#} (\alpha_0 \otimes \alpha_1)",
            font_size=36
        ).to_edge(UP)
        
        self.play(
            FadeOut(self.alpha0_dict["glow"]),
            FadeOut(self.alpha1_dict["glow"]),
            LaggedStart(
                FadeTransform(self.alpha0_dict["particles"].copy(), bridge),
                FadeTransform(self.alpha1_dict["particles"].copy(), bridge),
                lag_ratio=0.2
            ),
            run_time=3
        )
        self.add(time_indicator_group, time_dot, equation)
        self.play(
            t_tracker.animate.set_value(1),
            rate_func=linear,
            run_time=8
        )
        self.wait(2)
        
    def generate_bridge(self, source, target, t):
        bridge = VGroup()
        n = len(source)
        noise = 0.05  # Add perceptual randomness
        
        for s_dot, t_dot in zip(source, target):
            # Add Perlin-like noise to movement
            interp_point = interpolate(
                s_dot.get_center() + noise * np.random.randn(3),
                t_dot.get_center() + noise * np.random.randn(3),
                smooth(t)
            )
            color = interpolate_color(
                s_dot.get_color(), 
                t_dot.get_color(), 
                t + 0.1*np.sin(TAU*t)  # Add color oscillation
            )
            
            particle = Dot(
                interp_point,
                color=color,
                radius=s_dot.radius,
                fill_opacity=s_dot.fill_opacity
            )
            bridge.add(particle)
            
        return bridge

    def show_optimal_transport(self):
        # Scene 3: Optimal Transport River
        velocity_field = self.create_velocity_field()
        energy_diagram = self.create_energy_diagram()
        continuity_eq = MathTex(
            r"\text{div}(\alpha_t \nu_t) + \partial_t \alpha_t = 0",
            color=TEAL
        ).to_edge(UR)
        
        self.play(
            Create(velocity_field),
            FadeIn(energy_diagram),
            Write(continuity_eq),
            run_time=3
        )
        self.wait(3)
        
    def create_velocity_field(self):
        # Create dynamic streamlines with varying density
        streamlines = VGroup()
        n_lines = 50
        phase = ValueTracker(0)
        
        for i in range(n_lines):
            line = ParametricFunction(
                lambda t: self.velocity_path(i, phase.get_value(), t),
                t_range=[-PI, PI],
                color=interpolate_color(WHITE, BLUE_E, i/n_lines)
            )
            line.add_updater(lambda m, dt: m.become(
                ParametricFunction(
                    lambda t: self.velocity_path(i, phase.get_value(), t),
                    t_range=[-PI, PI],
                    color=m.color
                )
            ))
            streamlines.add(line)
        
        self.add(streamlines)
        self.play(phase.animate.set_value(TAU), run_time=5, rate_func=linear)
        return streamlines

    def velocity_path(self, seed, phase_val, t):
        np.random.seed(seed)
        return np.array([
            3 * np.cos(t + 0.5 * phase_val) + 0.5 * np.sin(3*t),
            2 * np.sin(t + 0.3 * phase_val) + 0.5 * np.cos(2*t),
            0
        ])
        
    def create_energy_diagram(self):
        # Animated energy minimization display
        axes = Axes(
            x_range=[0, 1],
            y_range=[0, 10, 2],
            axis_config={"color": WHITE}
        ).scale(0.5).to_edge(UL)
        
        labels = VGroup(
            axes.get_x_axis_label("t"),
            axes.get_y_axis_label("Energy")
        )
        
        # Simulated energy minimization curve
        curve = axes.plot(
            lambda x: 8 * np.exp(-3*x) + 0.5 * np.sin(20*x) + 1,
            color=RED
        )
        
        return VGroup(axes, labels, curve)

    def demonstrate_wasserstein(self):
        # Scene 4: Wasserstein Forge
        self.play(*[FadeOut(m) for m in self.mobjects])
        
        # Recreate original distributions
        alpha0 = self.alpha0_dict["particles"].copy()
        alpha1 = self.alpha1_dict["particles"].copy()
        grid = NumberPlane(
            x_range=[-5, 5],
            y_range=[-4, 4],
            background_line_style={
                "stroke_color": GREY_B,
                "stroke_width": 1
            }
        )
        
        # Transport map visualization
        transport_eq = MathTex(
            r"W_2^2(\alpha_0, \alpha_1) = \inf_{T_1} \int \|x - T_1(x)\|^2 d\alpha_0(x)",
            font_size=36
        ).to_edge(UP)
        
        # Hammer animation
        hammer = Line(ORIGIN, UP, color=GREY)\
            .add_tip()\
            .rotate(-45*DEGREES)\
            .move_to(UP*3 + RIGHT*2)
        
        # Displacement vectors
        vectors = self.create_displacement_vectors(alpha0, alpha1)
        
        self.play(
            Create(grid),
            FadeIn(alpha0),
            Write(transport_eq)
        )
        self.wait()
        
        # Animate hammer strikes
        for _ in range(3):
            self.play(
                Rotate(hammer, 90*DEGREES, about_point=hammer.get_end()),
                rate_func=there_and_back,
                run_time=0.5
            )
            self.play(
                grid.animate.apply_function(lambda p: self.transport_map(p)),
                alpha0.animate.apply_function(lambda p: self.transport_map(p)),
                vectors.animate.set_opacity(1),
                run_time=2
            )
        
        self.wait(2)
        
    def transport_map(self, point):
        # Custom transport deformation
        x, y, z = point
        return [
            x + 0.5 * np.sin(x/2) * np.cos(y/3),
            y + 0.5 * np.cos(x/3) * np.sin(y/2),
            z
        ]
        
    def create_displacement_vectors(self, source, target):
        vectors = VGroup()
        sample_points = [m.get_center() for m in source[::50]]
        
        for point in sample_points:
            start = point
            end = self.transport_map(point)
            length = np.linalg.norm(end - start)
            color = interpolate_color(
                GREEN, RED, length/3
            )
            vector = Arrow(
                start, end,
                color=color,
                tip_length=0.2,
                stroke_width=2
            )
            vectors.add(vector)
            
        vectors.set_opacity(0)
        return vectors

    def synthesize_benamou_brenier(self):
        # Scene 5: Theorem Synthesis
        self.play(*[FadeOut(m) for m in self.mobjects])
        
        # Create combined visualization
        bridge = self.generate_bridge(self.alpha0_dict["particles"], self.alpha1_dict["particles"], 0.5)
        velocity_field = self.create_velocity_field()
        forge = self.demonstrate_wasserstein()
        
        # Theorem text
        theorem_text = VGroup(
            Text("Benamou-Brenier Theorem", font_size=48),
            MathTex(r"W_2^2(\alpha_0, \alpha_1) = \min \int_0^1 \|\nu_t\|_{L^2(\alpha_t)}^2 dt"),
            Text("In the calculus of shapes,\nWasserstein is the sculptor,\nand Benamou-Brenier the chisel...",
                 t2c={"sculptor": BLUE, "chisel": GOLD},
                 font_size=24)
        ).arrange(DOWN, buff=0.5)
        
        self.play(
            FadeIn(bridge),
            Create(velocity_field),
            FadeIn(forge),
            run_time=3
        )
        self.play(
            Write(theorem_text[0]),
            run_time=2
        )
        self.play(
            TransformFromCopy(theorem_text[0], theorem_text[1]),
            run_time=2
        )
        self.play(
            FadeIn(theorem_text[2], shift=UP),
            run_time=2
        )
        self.wait(3)

# Render with: manim -pqh -v WARNING --disable_caching your_file.py CosmicProbabilityScene
```

量子电动力学 (QED)
```python
from manim import *
import numpy as np
import random


class CombinedScene(MovingCameraScene):
    def construct(self):
        #################################
        # 场景01：欢迎介绍界面
        #################################
        bg = Rectangle(width=self.camera.frame_width,
                       height=self.camera.frame_height)
        bg.set_fill(color=BLUE_D, opacity=1)
        bg.set_stroke(width=0)
        bg.set_z_index(-1)  # 背景在最底层
        self.add(bg)

        scene_label = Text("01", font_size=24, color=RED).to_corner(UR, buff=0.5)
        self.add(scene_label)

        # 创建用于星空闪烁的 ValueTracker 与星星
        star_tracker = ValueTracker(0)
        stars = VGroup()
        num_stars = 40
        for _ in range(num_stars):
            x = random.uniform(-self.camera.frame_width / 2, self.camera.frame_width / 2)
            y = random.uniform(-self.camera.frame_height / 2, self.camera.frame_height / 2)
            star = Dot(point=np.array([x, y, 0]), radius=0.03, color=WHITE)
            star.set_opacity(0.3)
            phase = random.uniform(0, 2 * np.pi)
            star.add_updater(lambda m, dt, phase=phase: m.set_opacity(
                0.3 + 0.2 * np.abs(np.sin(star_tracker.get_value() * 2 * np.pi + phase))
            ))
            stars.add(star)
        self.add(stars)
        star_tracker.add_updater(lambda m, dt: m.increment_value(dt))

        title = Text("大家好，欢迎来到本期数学讲解视频", font_size=48, color=WHITE)
        title.to_edge(UP)
        subtitle_text1 = Text("如何求解函数 ", font_size=36, color=WHITE)
        subtitle_formula = MathTex("f(x)=x^2", font_size=36)
        subtitle_text2 = Text(" 的切线方程", font_size=36, color=WHITE)
        subtitle = VGroup(subtitle_text1, subtitle_formula, subtitle_text2).arrange(RIGHT, buff=0.2)
        subtitle.next_to(title, DOWN, buff=0.5)

        self.play(FadeIn(title), run_time=1)
        self.play(Write(subtitle), run_time=1.5)
        self.play(self.camera.frame.animate.shift(0.2 * OUT), run_time=0.5)
        self.wait(1)
        star_tracker.clear_updaters()
        stars.clear_updaters()
        self.wait(1)

        self.play(FadeOut(Group(*self.mobjects)), run_time=1)
        self.clear()
        self.camera.frame.set(width=self.camera.frame_width, height=self.camera.frame_height)

        #################################
        # 场景02：问题背景与概念介绍
        #################################
        bg2 = Rectangle(width=self.camera.frame_width,
                        height=self.camera.frame_height)
        bg2.set_fill(color=GREY_E, opacity=1)
        bg2.set_stroke(width=0)
        bg2.set_z_index(-1)
        self.add(bg2)

        scene_label = Text("02", font_size=24, color=RED).to_corner(UR, buff=0.5)
        self.add(scene_label)

        explanation = Text(
            "切线是曲线在某一点的瞬时方向，在函数 f(x)=x^2 中，切线反映了曲线在该点的斜率变化。",
            font_size=28, color=BLACK)
        explanation.to_edge(LEFT).shift(LEFT * 0.5)

        axes = Axes(
            x_range=[-4, 4, 1],
            y_range=[-1, 16, 3],
            x_length=6,
            y_length=5,
            tips=True)
        axes.to_edge(RIGHT).shift(RIGHT * 0.5)
        axes.set_stroke(color=LIGHT_GREY, width=2)
        parabola = axes.plot(lambda x: x ** 2, x_range=[-3, 3], color=BLUE)

        a = 1
        tangent_point = axes.coords_to_point(a, a ** 2)
        dot = Dot(point=tangent_point, color=RED)
        dot.set_opacity(1)
        dot.add_updater(lambda m, dt: m.scale(1 + 0.1 * np.sin(self.renderer.time * 2 * np.pi)))

        self.play(Create(axes), run_time=2)
        self.play(Create(parabola), run_time=2)
        self.play(FadeIn(dot), run_time=1)
        self.play(FadeIn(explanation), run_time=2)
        self.wait(2)
        dot.clear_updaters()

        self.play(FadeOut(Group(*self.mobjects)), run_time=1)
        self.clear()
        self.camera.frame.set(width=self.camera.frame_width, height=self.camera.frame_height)

        #################################
        # 场景03：求解切线基本步骤展示
        #################################
        bg3 = Rectangle(width=self.camera.frame_width,
                        height=self.camera.frame_height)
        bg3.set_fill(color=GREY_E, opacity=1)
        bg3.set_stroke(width=0)
        bg3.set_z_index(-1)
        self.add(bg3)

        scene_label = Text("03", font_size=24, color=RED).to_corner(UR, buff=0.5)
        self.add(scene_label)

        step1 = MathTex(r"(a, a^2)", font_size=36)
        step2 = MathTex(r"f'(x)=2x,\quad f'(a)=2a", font_size=36)
        step3 = MathTex(r"y - a^2 = 2a(x - a)", font_size=36)
        step4 = MathTex(r"y = 2a(x - a) + a^2", font_size=36)
        steps = VGroup(step1, step2, step3, step4).arrange(DOWN, aligned_edge=LEFT, buff=0.8)
        steps.to_edge(LEFT).shift(RIGHT * 0.5)

        axes3 = Axes(
            x_range=[-4, 4, 1],
            y_range=[-1, 16, 3],
            x_length=6,
            y_length=6,
            tips=True)
        axes3.to_edge(RIGHT).shift(RIGHT * -0.5)
        axes3.set_stroke(color=LIGHT_GREY, width=2)
        parabola3 = axes3.plot(lambda x: x ** 2, x_range=[-3, 3], color=BLUE)
        tangent_point3 = axes3.coords_to_point(a, a ** 2)
        dot3 = Dot(point=tangent_point3, color=RED)
        dot3.set_opacity(1)
        # 计算切线（斜率 2，对应方向向量 [1, 2, 0]）
        direction = np.array([1, 2, 0])
        direction = direction / np.linalg.norm(direction)
        line_length = 6
        start_point = tangent_point3 - direction * (line_length / 2)
        end_point = tangent_point3 + direction * (line_length / 2)
        tangent_line = Line(start_point, end_point, color=ORANGE)

        self.play(FadeIn(steps[0]), run_time=1)
        self.wait(1)
        self.play(ReplacementTransform(steps[0].copy(), steps[1]), run_time=1)
        self.wait(1)
        self.play(ReplacementTransform(steps[1].copy(), steps[2]), run_time=1)
        self.wait(1)
        self.play(ReplacementTransform(steps[2].copy(), steps[3]), run_time=1)
        self.play(Create(axes3), run_time=2)
        self.play(Create(parabola3), run_time=2)
        self.play(FadeIn(dot3), run_time=1)
        self.play(Create(tangent_line), run_time=2)
        # 保持静态，不做额外的相机动画
        self.wait(2)

        self.play(FadeOut(Group(*self.mobjects)), run_time=1)
        self.clear()
        self.camera.frame.set(width=self.camera.frame_width, height=self.camera.frame_height)

        #################################
        # 场景04：理论原理与数学公式解析
        #################################
        bg4 = Rectangle(width=self.camera.frame_width,
                        height=self.camera.frame_height)
        bg4.set_fill(color=GREY_C, opacity=1)
        bg4.set_stroke(width=0)
        bg4.set_z_index(-1)
        self.add(bg4)

        scene_label = Text("04", font_size=24, color=RED).to_corner(UR, buff=0.5)
        self.add(scene_label)

        derivative_formula = MathTex(r"f'(x)=\lim_{h \to 0}\frac{f(x+h)-f(x)}{h}", font_size=36)
        derivative_formula.to_edge(UP)
        point_slope_formula = MathTex(r"y - y_1 = m(x - x_1)", font_size=36)
        point_slope_formula.to_edge(DOWN)
        self.play(FadeIn(derivative_formula), run_time=1.5)
        self.play(FadeIn(point_slope_formula), run_time=1.5)
        arrow = Arrow(start=LEFT, end=RIGHT, color=YELLOW)
        arrow.next_to(derivative_formula, RIGHT, buff=1)
        self.play(Create(arrow), run_time=1)
        self.wait(2)

        self.play(FadeOut(Group(*self.mobjects)), run_time=1)
        self.clear()
        self.camera.frame.set(width=self.camera.frame_width, height=self.camera.frame_height)

        #################################
        # 场景05：总结与回顾
        #################################
        # 背景直接使用相机 frame 的副本，确保始终覆盖视图
        bg5 = Rectangle(width=self.camera.frame_width,
                        height=self.camera.frame_height)
        bg5.set_fill(color=BLUE_D, opacity=1)
        bg5.set_stroke(width=0)
        bg5.set_z_index(-1)
        self.add(bg5)

        scene_label = Text("05", font_size=24, color=RED).to_corner(UR, buff=0.5)
        self.add(scene_label)

        summary_text = Text("总结", font_size=48, color=GOLD)
        summary_text.to_edge(UP)
        formula1 = MathTex(r"(a, a^2)", font_size=36)
        formula2 = MathTex(r"f'(x)=2x", font_size=36)
        formula3 = MathTex(r"y=2a(x-a)+a^2", font_size=36)
        formulas = VGroup(formula1, formula2, formula3).arrange(DOWN, aligned_edge=LEFT, buff=0.6)
        formulas.next_to(summary_text, DOWN, buff=1)
        question = Text("你认为切线方程还能帮助我们解决哪些类型的问题？", font_size=28, color=WHITE)
        question.to_edge(DOWN)
        self.play(FadeIn(summary_text), run_time=1)
        self.play(Write(formulas), run_time=2)
        self.play(FadeIn(question), run_time=1.5)
        self.wait(3)


if __name__ == "__main__":
    from manim import tempconfig

    # 使用 tempconfig 临时设置输出目录（这里指定输出到 "./output_video" 目录）
    with tempconfig({
        "media_dir": "./#(output_video)",
    }):
        scene = CombinedScene()
        scene.render()
```