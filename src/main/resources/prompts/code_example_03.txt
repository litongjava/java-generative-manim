```python
# -*- coding: utf-8 -*-
import os
import numpy as np
import requests
from contextlib import contextmanager
from manim import *
import hashlib
from moviepy import AudioFileClip # Correct import
import manimpango # For font checking

# --- Font Check --- (Ensure CJK font is available)
DEFAULT_FONT = "Noto Sans CJK SC" # Desired font for Chinese
available_fonts = manimpango.list_fonts()
final_font = None

if DEFAULT_FONT in available_fonts:
    print(f"Font '{DEFAULT_FONT}' found.")
    final_font = DEFAULT_FONT
else:
    print(f"Warning: Font '{DEFAULT_FONT}' not found. Trying fallback fonts...")
    fallback_fonts = ["PingFang SC", "Microsoft YaHei", "SimHei", "Arial Unicode MS"]
    found_fallback = False
    for font in fallback_fonts:
        if font in available_fonts:
            print(f"Switched to fallback font: '{font}'")
            final_font = font
            found_fallback = True
            break
    if not found_fallback:
        print(f"Warning: Neither '{DEFAULT_FONT}' nor fallback fonts found. Using Manim default. Chinese characters may not display correctly.")
        # final_font remains None

# --- Custom Colors ---
MY_DARK_BLUE = "#0d3b66"
MY_LIGHT_BLUE = "#faf0ca" # Light background/text color
MY_GOLD = "#f4d35e"      # Titles, highlights
MY_ORANGE = "#ee964b"    # Vectors, examples
MY_RED = "#f95738"        # Highlights (direction), force
MY_WHITE = "#FFFFFF"      # Subtitles
MY_BLACK = "#000000"      # Not used much with dark background
MY_GRAY = "#888888"        # Axes, dashed lines

# --- TTS Caching Setup ---
CACHE_DIR = r"#(output_path)/audio"
os.makedirs(CACHE_DIR, exist_ok=True)

class CustomVoiceoverTracker:
    """Tracks audio path and duration for TTS."""
    def __init__(self, audio_path, duration):
        self.audio_path = audio_path
        self.duration = duration

def get_cache_filename(text):
    """Generates a unique filename based on the text hash."""
    text_hash = hashlib.md5(text.encode('utf-8')).hexdigest()
    return os.path.join(CACHE_DIR, f"{text_hash}.mp3")

@contextmanager
def custom_voiceover_tts(text, token="123456", base_url="https://uni-ai.fly.dev/api/manim/tts"):
    """Fetches TTS audio, caches it, and provides path and duration."""
    cache_file = get_cache_filename(text)
    audio_file = cache_file

    if os.path.exists(cache_file):
        # print(f"Using cached TTS for: {text[:30]}...")
        pass # Use cached file
    else:
        # print(f"Requesting TTS for: {text[:30]}...")
        try:
            input_text_encoded = requests.utils.quote(text)
            url = f"{base_url}?token={token}&input={input_text_encoded}"
            response = requests.get(url, stream=True, timeout=60)
            response.raise_for_status()
            with open(cache_file, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk: f.write(chunk)
            audio_file = cache_file
            # print("TTS downloaded and cached.")
        except requests.exceptions.RequestException as e:
            print(f"TTS API request failed: {e}")
            tracker = CustomVoiceoverTracker(None, 0)
            yield tracker
            return
        except Exception as e:
            print(f"An error occurred during TTS processing: {e}")
            if os.path.exists(cache_file): os.remove(cache_file) # Clean up partial file
            tracker = CustomVoiceoverTracker(None, 0)
            yield tracker
            return

    # Get duration
    duration = 0
    if audio_file and os.path.exists(audio_file):
        try:
            with AudioFileClip(audio_file) as clip:
                duration = clip.duration
            # print(f"Audio duration: {duration:.2f}s")
        except Exception as e:
            print(f"Error processing audio file {audio_file}: {e}")
            audio_file = None
            duration = 0
    else:
        # print(f"TTS audio file not found or not created: {audio_file}")
        audio_file = None

    tracker = CustomVoiceoverTracker(audio_file, duration)
    try:
        yield tracker
    finally:
        pass # Keep cache

# -----------------------------
# CombinedScene: Explaining Vectors
# -----------------------------
class CombinedScene(Scene):
    """
    Explains the basic concept of vectors: magnitude and direction, with examples.
    """
    def setup(self):
        Scene.setup(self)
        # Set default font if found
        if final_font:
            Text.set_default(font=final_font)
        # Variable to hold the current scene number mobject
        self.current_scene_num_mob = None

    def update_scene_number(self, number_str):
        """Fades out the old scene number and fades in the new one."""
        new_scene_num = Text(number_str, font_size=24, color=MY_LIGHT_BLUE).to_corner(UR, buff=MED_LARGE_BUFF).set_z_index(10)
        animations = [FadeIn(new_scene_num, run_time=0.5)]
        if self.current_scene_num_mob:
            animations.append(FadeOut(self.current_scene_num_mob, run_time=0.5))
        self.play(*animations)
        self.current_scene_num_mob = new_scene_num # Update the reference

    def construct(self):
        # --- Scene Setup ---
        # Background
        bg = Rectangle(width=config.frame_width, height=config.frame_height,
                       fill_color=MY_DARK_BLUE, fill_opacity=1.0, stroke_width=0).set_z_index(-10)
        self.add(bg)

        # --- Section 1: Introduction ---
        self.update_scene_number("01") # Update scene number

        title = Text("什么是向量？", font_size=60, color=MY_GOLD)
        title.to_edge(UP, buff=MED_LARGE_BUFF)

        definition_text = Text("向量是一个既有大小又有方向的量。", font_size=36, color=MY_LIGHT_BLUE)
        definition_text.next_to(title, DOWN, buff=MED_LARGE_BUFF)

        # Generic Vector Arrow
        vector_arrow = Arrow(start=LEFT*2+DOWN*1, end=RIGHT*2+UP*1, color=MY_ORANGE, buff=0)

        # Narration 1: Intro
        voice_text_01 = "大家好！今天我们来了解一下什么是向量。向量是一个既有大小又有方向的量。"
        with custom_voiceover_tts(voice_text_01) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path)
            else:
                print("Warning: Narration 1 TTS failed.")

            subtitle_voice = Text(voice_text_01, font_size=28, color=MY_WHITE, width=config.frame_width - 2, should_center=True).to_edge(DOWN, buff=MED_SMALL_BUFF)

            self.play(
                AnimationGroup(
                    FadeIn(title),
                    FadeIn(subtitle_voice, run_time=0.5),
                    lag_ratio=0.0
                ),
                run_time=1.0
            )
            self.play(FadeIn(definition_text), run_time=1.5)
            self.play(Create(vector_arrow), run_time=1.5)

            anim_duration = 1.0 + 1.5 + 1.5
            wait_time = max(0, tracker.duration - anim_duration - 0.5)
            if wait_time > 0: self.wait(wait_time)
            self.play(FadeOut(subtitle_voice), run_time=0.5)

        # --- Section 2: Magnitude and Direction ---
        self.update_scene_number("02") # Update scene number

        magnitude_text = Text("大小 (Magnitude): 向量的长度 (模)", font_size=32, color=MY_LIGHT_BLUE)
        direction_text = Text("方向 (Direction): 向量所指向的方向", font_size=32, color=MY_LIGHT_BLUE)
        desc_group = VGroup(magnitude_text, direction_text).arrange(DOWN, aligned_edge=LEFT, buff=MED_SMALL_BUFF)
        # Position description group below the vector
        desc_group.next_to(vector_arrow, DOWN, buff=LARGE_BUFF)

        # Highlight Magnitude (Brace)
        brace_mag = Brace(vector_arrow, direction=vector_arrow.copy().rotate(PI/2).get_unit_vector(), color=MY_GOLD)
        brace_mag_label = Text("大小", font_size=30).set_color(MY_GOLD)
        brace_mag.put_at_tip(brace_mag_label) # Position the Text label

        # Highlight Direction (Focus on Arrowhead)
        arrow_tip = vector_arrow.get_tip()
        direction_highlight = Circle(radius=0.3, color=MY_RED, stroke_width=3).move_to(arrow_tip.get_center())

        # Narration 2: Magnitude/Direction
        voice_text_02 = "你可以把它想象成一个带箭头的线段。线段的长度代表向量的大小，也叫模。箭头的方向代表向量的方向。"
        with custom_voiceover_tts(voice_text_02) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path)
            else:
                print("Warning: Narration 2 TTS failed.")

            subtitle_voice = Text(voice_text_02, font_size=28, color=MY_WHITE, width=config.frame_width - 2, should_center=True).to_edge(DOWN, buff=MED_SMALL_BUFF)

            self.play(FadeIn(subtitle_voice), run_time=0.5)
            self.play(FadeIn(desc_group[0]), GrowFromCenter(brace_mag), FadeIn(brace_mag_label), run_time=2.0)
            self.play(FadeIn(desc_group[1]), Create(direction_highlight), run_time=2.0)

            anim_duration = 0.5 + 2.0 + 2.0
            wait_time = max(0, tracker.duration - anim_duration - 0.5)
            if wait_time > 0: self.wait(wait_time)
            # Fade out highlights and subtitle, keep main elements
            self.play(FadeOut(subtitle_voice), FadeOut(brace_mag), FadeOut(brace_mag_label), FadeOut(direction_highlight), run_time=0.5)

        # Fade out definition, arrow, and description for examples
        self.play(FadeOut(definition_text), FadeOut(vector_arrow), FadeOut(desc_group), run_time=1.0)

        # --- Section 3: Examples ---
        self.update_scene_number("03") # Update scene number

        examples_title = Text("例子 (Examples):", font_size=40, color=MY_GOLD)
        examples_title.next_to(title, DOWN, buff=LARGE_BUFF).align_to(title, LEFT)
        self.play(FadeIn(examples_title), run_time=1.0)

        # Narration 3: Examples
        voice_text_03 = "向量在物理学中有很多应用。例如，速度：像“向东 20 米每秒”就是一个向量，它既有大小（20米每秒），也有方向（东）。位移：比如“从 A 点到 B 点”，描述了方向和距离。还有力：例如“向右推力 5 牛顿”，指定了力的方向和大小。"
        with custom_voiceover_tts(voice_text_03) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path)
            else:
                print("Warning: Narration 3 TTS failed.")

            subtitle_voice = Text(voice_text_03, font_size=28, color=MY_WHITE, width=config.frame_width - 2, should_center=True).to_edge(DOWN, buff=MED_SMALL_BUFF)
            self.play(FadeIn(subtitle_voice), run_time=0.5)

            # Example 1: Velocity
            velocity_text = Text("速度: 例如，“向东 20 米/秒”", font_size=32, color=MY_LIGHT_BLUE)
            velocity_arrow = Arrow(start=LEFT*2, end=RIGHT*2, color=MY_ORANGE, buff=0)
            velocity_label = Text("20 m/s", font_size=24, color=MY_ORANGE).next_to(velocity_arrow, DOWN)
            velocity_group = VGroup(velocity_text, velocity_arrow, velocity_label).arrange(DOWN, buff=MED_LARGE_BUFF)
            velocity_group.next_to(examples_title, DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)
            self.play(FadeIn(velocity_group), run_time=1.5)
            self.wait(3.0) # Wait for narration part

            # Example 2: Displacement
            displacement_text = Text("位移: 例如，“从 A 点到 B 点”", font_size=32, color=MY_LIGHT_BLUE)
            point_a = Dot(LEFT*2+DOWN*1, color=MY_GOLD)
            point_b = Dot(RIGHT*2+UP*1, color=MY_GOLD)
            label_a = Text("A", font_size=24, color=MY_GOLD).next_to(point_a, DL)
            label_b = Text("B", font_size=24, color=MY_GOLD).next_to(point_b, UR)
            displacement_arrow = Arrow(point_a.get_center(), point_b.get_center(), color=MY_ORANGE, buff=0.1)
            # FIX: Arrange displacement elements carefully
            displacement_content = VGroup(point_a, point_b, label_a, label_b, displacement_arrow)
            displacement_group = VGroup(displacement_text, displacement_content).arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)
            displacement_group.next_to(examples_title, DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)
            # FIX: Use FadeOut/FadeIn instead of Transform
            self.play(FadeOut(velocity_group, run_time=0.75), FadeIn(displacement_group, run_time=0.75))
            self.wait(3.0) # Wait for narration part

            # Example 3: Force
            force_text = Text("力: 例如，“向右推力 5 牛顿”", font_size=32, color=MY_LIGHT_BLUE)
            box = Square(side_length=1.0, color=MY_LIGHT_BLUE, fill_opacity=0.5).move_to(ORIGIN)
            force_arrow = Arrow(start=box.get_left()+LEFT*0.5, end=box.get_right()+RIGHT*0.5, color=MY_RED, buff=0)
            force_label = Text("5 N", font_size=24, color=MY_RED).next_to(force_arrow, UP)
            # FIX: Arrange force elements
            force_content = VGroup(box, force_arrow, force_label) # Group visual elements
            force_group = VGroup(force_text, force_content).arrange(DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)
            force_group.next_to(examples_title, DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)
            # FIX: Use FadeOut/FadeIn instead of Transform
            self.play(FadeOut(displacement_group, run_time=0.75), FadeIn(force_group, run_time=0.75))
            self.wait(3.0) # Wait for narration part

            # Calculate wait time
            anim_duration = 0.5 + 1.5 + 3.0 + 1.5 + 3.0 + 1.5 + 3.0 # Adjusted for FadeOut/In
            wait_time = max(0, tracker.duration - anim_duration - 0.5)
            if wait_time > 0: self.wait(wait_time)
            self.play(FadeOut(subtitle_voice), run_time=0.5)

        # FIX: Fade out examples title along with the last example group
        self.play(FadeOut(examples_title), FadeOut(force_group), run_time=1.0)

        # --- Section 4: Mathematical Representation ---
        self.update_scene_number("04") # Update scene number

        math_title = Text("数学表示 (Mathematical Representation):", font_size=40, color=MY_GOLD)
        math_title.next_to(title, DOWN, buff=LARGE_BUFF).align_to(title, LEFT)

        math_desc1 = Text("在数学中，向量通常用坐标表示。", font_size=32, color=MY_LIGHT_BLUE)
        math_desc1.next_to(math_title, DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)

        # Coordinate System
        axes = Axes(
            x_range=[-1, 5, 1], y_range=[-1, 5, 1],
            x_length=5, y_length=5,
            axis_config={"color": MY_GRAY, "include_tip": True, "stroke_width": 2, "include_numbers": True},
            tips=False
        ).add_coordinates()
        # Position axes more centrally or to the right
        axes.move_to(RIGHT*2.5 + DOWN*0.5)

        # Vector (3, 4)
        start_point = axes.c2p(0, 0)
        end_point = axes.c2p(3, 4)
        vec_3_4 = Vector(end_point - start_point, color=MY_ORANGE)
        vec_3_4.shift(start_point - vec_3_4.get_start()) # Move start to origin

        vec_label = MathTex("(3, 4)", font_size=36, color=MY_ORANGE).next_to(vec_3_4.get_end(), UR, buff=SMALL_BUFF)

        # Components
        line_horz = DashedLine(axes.c2p(0, 4), axes.c2p(3, 4), color=MY_GRAY)
        line_vert = DashedLine(axes.c2p(3, 0), axes.c2p(3, 4), color=MY_GRAY)
        label_horz = MathTex("3", font_size=30, color=MY_GRAY).next_to(axes.c2p(1.5, 0), DOWN)
        label_vert = MathTex("4", font_size=30, color=MY_GRAY).next_to(axes.c2p(0, 2), LEFT)
        components = VGroup(line_horz, line_vert, label_horz, label_vert)

        # FIX: Use width for text wrapping and position carefully
        math_desc2 = Text(
            "例如，向量 (3, 4) 表示一个从原点出发，水平方向移动 3 个单位，垂直方向移动 4 个单位的向量。",
            font_size=32, color=MY_LIGHT_BLUE, line_spacing=1.2,
            width=config.frame_width / 2 - 2 # Limit width to prevent overflow
        )
        # Position text to the left of the axes area
        math_desc2.next_to(math_desc1, DOWN, buff=MED_LARGE_BUFF, aligned_edge=LEFT)
        # Ensure it's on the left side of the screen
        math_desc2.align_to(math_desc1, LEFT) # Align with desc1
        math_desc2.shift(DOWN*0.5) # Add some space below desc1

        # Group text elements on the left
        left_text_group = VGroup(math_title, math_desc1, math_desc2)
        left_text_group.to_edge(LEFT, buff=1.0) # Anchor group to left edge

        # Narration 4: Math Representation
        voice_text_04 = "在数学中，我们经常用坐标来表示向量。比如在二维平面上，向量 (3, 4) 就表示一个从原点出发，先向右移动 3 个单位，再向上移动 4 个单位的向量。"
        with custom_voiceover_tts(voice_text_04) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path)
            else:
                print("Warning: Narration 4 TTS failed.")

            subtitle_voice = Text(voice_text_04, font_size=28, color=MY_WHITE, width=config.frame_width - 2, should_center=True).to_edge(DOWN, buff=MED_SMALL_BUFF)

            # FIX: Animate left text and right axes separately to avoid overlap
            self.play(FadeIn(math_title), FadeIn(math_desc1), run_time=1.5)
            self.play(Create(axes), run_time=1.5)
            self.play(FadeIn(subtitle_voice), run_time=0.5)
            self.play(Create(vec_3_4), FadeIn(vec_label), run_time=1.5)
            self.play(FadeIn(math_desc2), run_time=1.5) # Fade in wrapped text
            self.play(Create(components), run_time=1.5)

            anim_duration = 1.5 + 1.5 + 0.5 + 1.5 + 1.5 + 1.5
            wait_time = max(0, tracker.duration - anim_duration - 0.5)
            if wait_time > 0: self.wait(wait_time)
            self.play(FadeOut(subtitle_voice), run_time=0.5)

        # FIX: Group all math elements for fade out
        math_group = VGroup(left_text_group, axes, vec_3_4, vec_label, components)
        self.play(FadeOut(math_group), run_time=1.0)

        # --- Section 5: Conclusion ---
        self.update_scene_number("05") # Update scene number

        conclusion_text = Text("这就是向量的基本概念！", font_size=48, color=MY_GOLD)
        conclusion_text.move_to(ORIGIN)

        # Narration 5: Conclusion
        voice_text_05 = "这就是向量的基本概念！希望这个解释对你有帮助。"
        with custom_voiceover_tts(voice_text_05) as tracker:
            if tracker.audio_path and tracker.duration > 0:
                self.add_sound(tracker.audio_path)
            else:
                print("Warning: Narration 5 TTS failed.")

            subtitle_voice = Text(voice_text_05, font_size=28, color=MY_WHITE, width=config.frame_width - 2, should_center=True).to_edge(DOWN, buff=MED_SMALL_BUFF)

            # FIX: Fade out the main title explicitly
            self.play(FadeOut(title), run_time=0.5)
            self.play(FadeIn(conclusion_text), FadeIn(subtitle_voice), run_time=1.5)

            anim_duration = 0.5 + 1.5
            wait_time = max(0, tracker.duration - anim_duration - 0.5)
            if wait_time > 0: self.wait(wait_time)
            self.play(FadeOut(subtitle_voice), run_time=0.5)

        # Final wait before ending
        self.wait(2)
        # Fade out the last scene number
        if self.current_scene_num_mob:
            self.play(FadeOut(self.current_scene_num_mob))

# --- Main execution block ---
if __name__ == "__main__":
    # Basic configuration
    config.pixel_height = 1080  # Set resolution height
    config.pixel_width = 1920   # Set resolution width
    config.frame_rate = 30      # Set frame rate
    config.output_file = "CombinedScene"  # Specify output filename
    config.disable_caching = True  # Disable caching

    # Set output directory using placeholder
    config.media_dir = r"#(output_path)" # IMPORTANT: Use the placeholder

    # Create and render the scene
    scene = CombinedScene()
    scene.render()

    print(f"Scene rendering finished. Output in: {config.media_dir}")
```